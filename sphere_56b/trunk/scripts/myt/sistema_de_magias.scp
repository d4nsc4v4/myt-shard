[comment sistema_de_magias]

        -=OFFSETS DAS MAGIAS=-
0 a 99          Padrão
100 a 149       Destruição (Magery)
150 a 199       Restauração (Focus)
200 a 249       Alteração (Spellweavung)
250 a 299       Necromancia (Necromancy)
300 a 349       Ilusão - Bardspells (Musicianship)
350 a 324       Efeitos de armadilhas
325 a 349       Efeitos de maldições


        -=ToDo=-
- Apagar magias da DB quando char for deletado
- Modificar quantas vezes tem que acertar uma spell para aprender:
        A = SKILLREQ/20
        B = -(INSCRIPTION/33)
        C = -(SkillDaMagia/100)
    Tem que acertar A+B+C vezes.
- Refazer o sistema de encantar itens
- Encantar armas/armaduras

        -=TAGS UTILIZADOS=-
tag.mage_spellid
tag.mage_know
tag.mage_source
tag.mage_mana
tag.mage_actdiff
tag.mage_skill
tag.mage_uid
ctag.mage.gem
ctag.mage.power
ctag.mage.enchant_spell


@Spellselect
argn1=magia
argn2=mana
argn3=3 se esta começando, 2 se passou no teste (é chamado 2x)
argo=objeto de quem está se castando
O que faz:
- Guarda o objeto de onde está se castando (UID do mago, UID do scroll, UID da wand, UID da gema)
Se é o mago castando por WoP:
 Se sabe a magia:
  - Proceder normal
 Se não sabe a magia:
  - Mana += 25%
Se é mago usando scroll
 Se sabe a magia:
  - Não gasta mana
 Se não sabe a magia
  - Gasta mana
Se é mago usando gema ou wand
  - Não gasta mana

@spellcast
argn1=magia
argn2=dificuldade ajustavel
argn3=resultado do cálculo de dificuldade
O que faz:
- Verifica o objeto que castou a magia (mago via WoP, scroll, wand ou gema
Se é o mago castando por WoP:
 Se sabe a magia:
  - Proceder normal
 Se não sabe a magia:
  - Dificuldade += 25%
Se é mago usando scroll
 Se sabe a magia:
  - Dificuldade -= 25%
 Se não sabe a magia
  - Proceder normal
Se é mago usando gema ou wand
  - Dificuldade 0

Foram usados IFs encadeados em alguns blocos em ordens específicas para diminuir o impacto
no processamento de chamadas mais corriqueiras.

Caminho                 Oposto          Paradoxal
Alteração               Destruição      Necromancia
Destruição              Alteração       Restauração
Necromancia             Restauração     Alteração
Restauração             Necromancia     Destruição

//************************************************************************************
//************************************************************************************
//************************************************************************************
//************************************************************************************

[DEFNAME MAGE_SYSTEM]
MAGE_SELF               1
MAGE_WAND               2
MAGE_GEM                3
MAGE_SCROLL             4

MAGE_SPELL_KNOWN        1
MAGE_SPELL_UNKNOWN      0

MAGE_LEARN_RATIO        16
MAGE_LEARN_OFFSET       5
MAGE_LEARN_DECAY        60*60*24*3

MAGE_LEARNING           1
MAGE_KNOWN              2


[PLEVEL 4]
mage_initSpells
mage_KnowSpell
mage_addSpell
mage_learnSpell
mage_loadSpells
mage_forgetSpell

[PLEVEL 6]
//Infelizmente, Anti-Dragazul
xmage_initSpells
xmage_KnowSpell
xmage_addSpell
xmage_learnSpell
xmage_loadSpells
xmage_forgetSpell

//////////////////////////////////////FUNCTIONS///////////////////////////////


////// Funções básicas utilizadas em todo o script ou chamadas em outras Events como e_geral.

//***********************************************************
// mage_sonsumeMana <mana>
//***********************************************************
//Consome do mago <argn> de mana e retorna quanta mana ele tem.
[FUNCTION mage_consumeMana]
if (<mana> < <argn>)
 mana=0
else
 mana -= <argn>
endif
return <mana>

//***********************************************************
// mage_clearTags
//***********************************************************
//Apaga todas as tags referentes a castar magias
//Usa-se tags pois ctags não são permitidas em NPCs.
[FUNCTION mage_clearTags]
tag.mage_spellid=
tag.mage_know=
tag.mage_source=
tag.mage_mana=
tag.mage_actdiff=
tag.mage_skill=
tag.mage_uid=
if (<IsPlayer>)
 ctag.mage.gem=
 ctag.mage.power=
 ctag.mage.enchant_spell=
endif


//***********************************************************
// mage_skillgain
//***********************************************************
//Evita magos ganharem skill em spells muito simples para seu nível.
[FUNCTION mage_skillgain]
try LOCAL.MY=<SRC.<DEF.SKILL_<streat <serv.spell.<tag0.mage_spellid>.skillreq>>>>
LOCAL.ACT=<strarg <serv.spell.<tag0.mage_spellid>.skillreq>>+300
if (<local.my> < <local.act>)
 loca.skillname=SKILL_<streat <serv.spell.<tag0.mage_spellid>.skillreq>>
 //Checar caminhos opostos
 if (<DEF.<local.skillname>>==<DEF.SKILL_Spellweaving>) && (<Magery>)
  magery -= 1
 elif (<DEF.<local.skillname>>==<DEF.SKILL_Magery>) && (<Spellweaving>)
  spellweaving -= 1
 elif (<DEF.<local.skillname>>==<DEF.SKILL_Necromancy>) && (<Focus>)
  focus -= 1
 elif (<DEF.<local.skillname>>==<DEF.SKILL_Focus>) && (<Necromancy>)
  necromancy -= 1
 endif
 //Trigar ganho de skill
 skill_gain SKILL_<streat <serv.spell.<tag0.mage_spellid>.skillreq>>
endif

//***********************************************************
// mage_success
//***********************************************************
//chamado no @SKILLSUCCESS para skills Magery, Necromancy, Focus e SpellWeaving
[FUNCTION mage_success]
IF !<tag0.mage_spellid>
 return 1
endif
if <tag0.mage_source>==<DEF.MAGE_SELF> && !<tag0.mage_know>
 serv.log [mage_success] S: <tag0.mage_spellid> <serv.spell.<tag0.mage_spellid>.name>
 mage_learnSpell <tag0.mage_spellid>
endif
if <tag0.mage_source>==<DEF.MAGE_WAND>
 obj=<tag.mage_uid>
 obj.more2 -= 1
 obj.update
 if <obj.more2> < 1
  if <obj.layer>        //É wand, não gem
   obj.morex=0
   sysmessagered O poder de <obj.name> se esvaiu.
   if !<IsEmpty <obj.tag.name>>
    obj.name=<obj.tag.name>
   endif
  else                  //É gem
   sysmessagered <obj.name> some sem deixar vestigios.
   obj.timerf 1,decrement
  endif
 endif
endif
if <tag0.mage_source>==<DEF.MAGE_SCROLL>
 uid.<tag.mage_uid>.decrement
 sysmessageorange O pergaminho desintegra-se magicamente
endif
mage_consumeMana <tag.mage_mana>
mage_skillgain
serv.log mage_success <serv.spell.<tag0.mage_spellid>.name>
mage_cleartags
TRIGGER @TownSpellSuccess,<DEF.TAT_AS_ARGN>,<tag0.mage_spellid>
return 6

//***********************************************************
// mage_fail
//***********************************************************
//chamado no @SKILLFAIL para skills Magery, Necromancy, Focus e SpellWeaving
[FUNCTION mage_fail]
//Magery
if <tag0.mage_source>==<DEF.MAGE_SCROLL>
 uid.<tag.mage_uid>.decrement
 sysmessageyellow O pergaminho se esfarelou em sua mao.
endif
mage_consumeMana <src.tag0.mage_mana>
serv.log SKILLFAIL <serv.spell.<tag0.mage_spellid>.name>
IF (<tag0.mage_know>)
 mage_skillgain
endif
mage_cleartags

//***********************************************************
// mage_GetSpellRunes <magia>
//***********************************************************
//Retorna a palavra do poder para a spell <args>
[FUNCTION mage_GetSpellRunes]
local.rop=<SERV.SPELL.<ARGV[0]>.RUNES>
local.sk=<streat <SERV.SPELL.<ARGV[0]>.SKILLREQ>>
local.i=1
local.wop ="<DEF.RUNE_<local.sk>_<strsub 0 1 <local.rop>>> "
WHILE !<IsEmpty <strsub <local.i> 1 <local.rop>>>
 local.wop .= "<DEF.RUNE_<local.sk>_<strsub <dlocal.i> 1 <local.rop>>> "
 local.i += 1
END
return <strtrim <local.wop>>

//***********************************************************
// mage_enchant_gem <UIDgem>
//***********************************************************
//Abre dialogo para encantar uma gema com pontos ou magia
[FUNCTION mage_enchant_gem]
if (!<argo>)
 sysmessageyellow Selecione a pedra lapidada
 targetf mage_enchant_gem
 return 1
elif (!<argo.isitem>)
 sysmessagered Polimorfismo com gemas? Nao...
 return 1
elif (<argo.type>!=t_gem_stoned) || (<argo.topobj>!=<src>)
 sysmessagered Impossivel encantar isso.
 return 1
elif (<argo.amount> > 1)
 sysmessagered Impossivel mais de uma por vez.
 return 1
elif (<argo.more2>)
 sysmessagered Esta gema ja foi encantada.
 return 1
endif
//Limpa o cachê e salva a pedra.
mage_cleartags
src.ctag.mage.gem=<argo>
src.ctag.mage_skill=Skill_<serv.skill.<eval <argo.tdata1>>.key>
dialog d_spellbook 3
return 1

//***********************************************************
// mage_enchant_gem_select_spell
//***********************************************************
//Selecinou a magia <argn> como sendo a magia do encantamento de uma gema
[FUNCTION mage_enchant_gem_select_spell]
ctag.mage.enchant_spell=<argn>
dialog d_spellbook 3
return 1





//*******************************************************************************
//
/////////////////////////////Manejar magias e DB/////////////////////////////////
//
//*******************************************************************************

//***********************************************************
// mage_wipeSpells
//***********************************************************
//Limpa todas as magias do player <default> da DB
[FUNCTION mage_wipeSpells]
DB.QUERY="DELETE FROM spellbooks WHERE player='<DB.ESCAPEDATA <UID>>';"

//***********************************************************
// mage_initSpells [<spell>]
//***********************************************************
//Limpa todas as magias do player <default> e começa de novo
[FUNCTION mage_initSpells]
mage_wipeSpells
if (!<IsEmpty <args>>)
 tag.spells=;<args>;
else
 tag.spells=;
endif

//***********************************************************
// mage_addSpell <spell>
//***********************************************************
//Adiciona uma magia para o jogador <default> na DB e na lista local.
[FUNCTION mage_addSpell]
if (<isNum <argv0>>)
 local.spell=<serv.spell.<argv0>.defname>
else
 local.spell=<argv0>
endif
if (!<serv.spell.<local.spell>.defname>)
 return 0
endif
IF <mage_KnowSpell <local.spell>>
 return 0
else
 IF (<IsEmpty <tag.spells>>)
  mage_initSpells <local.spell>
 ELSE
  tag.spells .=<local.spell>;
 ENDIF
ENDIF
if (<IsPlayer>)
 DB.QUERY="INSERT INTO spellbooks SET player='<DB.ESCAPEDATA <src.uid>>', skill='<DB.ESCAPEDATA <streat <serv.spell.<local.spell>.skillreq>>>',diff='<DB.ESCAPEDATA <eval <strarg <serv.spell.<local.spell>.skillreq>>>>', spellid='<DB.ESCAPEDATA <local.spell>>';"
endif

//***********************************************************
// mage_loadSpells
//***********************************************************
//Carrega as magias do jogador <default> da DB para a lista local.
[FUNCTION mage_loadSpells]
DB.QUERY="SELECT spellid FROM spellbooks WHERE player='<DB.escapedata <UID>>' ORDER BY diff ASC;"
tag.spells=;<DB.ROW.0.spellid>;
for r 1 <eval <DB.ROW.NUMROWS>-1>
 if (!<IsEmpty <DB.ROW.<dlocal.r>.spellid>>)
  tag.spells .=<DB.ROW.<dlocal.r>.spellid>;
 endif
end

//***********************************************************
// mage_forgetSpell <spell>
//***********************************************************
//Apaga uma dada magia da DB e carrega novamente a lista local para o jogador <default>
[FUNCTION mage_forgetSpell]
if (<IsNum <argv[0]>>)
 local.spellid=<serv.spell.<argv[0]>.defname>
else
 local.spellid=<argv[0]>
endif
DB.EXECUTE="DELETE FROM spellbooks WHERE player='<DB.ESCAPEDATA <UID>>' AND spellid='<DB.ESCAPEDATA <local.spellid>>'";
mage_loadSpells
  
[FUNCTION mage_KnowSpell]
//Checa na lista local se o jogador conhece a dada spell
IF (STRMATCH(*;<serv.spell.<argn>.defname>;*,<src.tag.spells>))// || (STRMATCH(;<serv.spell.<argn>.defname>;*,<src.tag.spells>)) || (STRMATCH(*;<serv.spell.<argn>.defname>;,<src.tag.spells>))
 return 1
ENDIF
return 0


//*******************************************************************************
//
////////////////////////////Aprendizado de magias////////////////////////////////
//
//*******************************************************************************

//***********************************************************
// i_mry_learn_spell
//***********************************************************
//Memória que guarda que o <cont> está aprendendo a spell
//more1 é a spell
//more2 é quantos sucessos ele ainda precisa para aprender efetivamente a spell.
//more2 inicial é <spell.skillreq>/<DEF.MAGE_LEARN_RATIO>
//Some e deixa de aprender a spell quando correr o timer que é <DEF.MAGE_LEARN_DECAY>
[ITEMDEF i_mry_learn_spell]
id=i_deed
name=Aprendendo magia
type=t_eq_script
layer=layer_special

on=@create
//color=memory_learnSpell               //Sim, o tipo de memoria fica no Color. Sempre foi assim desde o Sphere 0.54
//attr=012

on=@timer
f_sendMessage <cont>,Voce nao consegue mais se lembrar o que tinha aprendido sobre <serv.spell.<more1>.name>,028
remove
return 1

//***********************************************************
// mage_getIncLearning <spell>
//***********************************************************
//Retorna quantas vezes o char tem que acertar a magia para aprender
//inc=dificuldade-skill
[FUNCTION mage_getIncLearning]
local.inc=<eval <strarg <serv.spell.<argv[0]>.skillreq>>-<src.<DEF.Skill_<streat <serv.spell.<argv[0]>.skillreq>>>>>

//inc=inc/ratio
local.inc /= <DEF.MAGE_LEARN_RATIO>

//inc += offset
local.inc=<QVAL <local.inc> <= <DEF.MAGE_LEARN_OFFSET>?<DEF.MAGE_LEARN_OFFSET>:<local.inc>+<DEF.MAGE_LEARN_OFFSET>>

//inc += magias aprendendo
local.inc += <mage_countLearningSpells>
return <local.inc>

//***********************************************************
// mage_learnSpell <spell>,[<value>]
//***********************************************************
[FUNCTION mage_learnSpell]
//Faz o char aprender a spell <argv[0]>. <ARGV[1]> é opcional, quantas vezes vale esta tentativa.
//Retorna 1 se o aprendizado terminou.
//player.mage_learnSpell <spelldefname>

if !<serv.spell.<argn>>
 serv.log [MAGIA] <TAG.NAME> [<ACCOUNT>] :: Magia '<args>' nao existe.
 return 0
endif

if (!0<argv[1]>)
 local.inc=1
else
 local.inc=<argv[1]>
endif

args=<serv.spell.<argn>.defname>

local.memory=<mage_findLearningSpell <args>>
if !<local.memory>
 //Ainda não começou a aprender essa. iniciar.
 local.learning=<mage_countLearningSpells>
 serv.newitem i_mry_learn_spell
 new.link=<UID>
 new.cont=<UID>
 new.more1 <args>
 new.timer <DEF.MAGE_LEARN_DECAY>
 local.sname=<serv.resources.<args>.name>
 new.name=Learn Spell (<local.sname>)
 sysmessageyellow Voce comecou a aprender uma magia nova: <local.sname>
 sysmessageyellow Aprendendo agora <eval <local.learning>+1> novas magias
 obj=<new>
else
 obj=<local.memory>
endif

//Já tá aprendendo a magia. Incrementar.
obj.more2 += <local.inc>
if <obj.more2> >= <mage_getIncLearning <obj.more1>>
 //terminou o aprendizado
 mage_addSpell <serv.resources.<obj.more1>.defname>
 timerf 3 sysmessageorange,Voce aprendeu uma magia nova: <serv.resources.<obj.more1>.name>
 timerf 3 psfx,<serv.resources.<obj.more1>.SOUND>
 obj.remove
 return 1
else
 obj.timer=<DEF.MAGE_LEARN_DECAY>
endif
return 0

//***********************************************************
// mage_countLearningSpells
//***********************************************************
//Conta quantas spells o player está aprendendo.
[FUNCTION mage_countLearningSpells]
local.n=0
FORCHARLAYER 30// memory_learnSpell
 IF (<defname>==i_mry_learn_spell)
  local.n += 1
 ENDIF
ENDFOR
return <local.n>

//***********************************************************
// mage_findLearningSpell
//***********************************************************
//Retorna a UID da memoria de aprendizado de magia da magia <args>
[FUNCTION mage_findLearningSpell]
FORCHARLAYER 30//memory_learnSpell
 if (<defname>==i_mry_learn_spell)
  if <more1>==<args>
   return <uid>
  endif
 endif
ENDFOR
return 0

//***********************************************************
// mage_paradoxEffect
//***********************************************************
//Causa uma coisa ruim para o mago que usa caminhos da magia paradoxais.
DOSWITCH <argn>
 spelleffect s_queimadura,100.0,<src>//Só um aviso
 Buff_Int <eval 40-<int>,<eval 60*60*4>//40 de int por 4 horas
 damage <R13,30>,dam_god,<src>//Dano de 13 a 30
 Buff_Int <eval 27-<int>,<eval 60*60*8>//27 de int por 8 horas
 uid.<f_conjure_creature {c_elem_earth 1 c_elem_water 1 c_elem_air 1 c_elem_fira 1},<eval 60*30>>.attack <uid>//NPC encrenca
 Buff_Int <eval 17-<int>,<eval 60*60*12>//17 de int por 12 horas
 f_polymorph <body>,021,<eval 60*60*24*7>//Ficar vermelho por uma semana
 stonned <eval 60*60*12>//Vira estatua por 12 horas
 Buff_Int <eval 5-<int>,<eval 60*60*24>//5 de int por 1 dia
 f_polymorph c_snake,colors_blue,<eval 60*60*24>//Vira uma cobra azul por 1 dia
 go 5284,620,20//Vai pro INFENO!
ENDDO
if (<local.s> > 10)
 kill
endif
timerf 5,psfx,0246
sysmessagered Voce esta sofrendo efeitos do Paradoxo!

//***********************************************************
// mage_CalcEnchant
//***********************************************************
//CALL mage_CalcEnchant
//Calcula e retorna como LOCAL mana usada, reags, tempo de preparação, custo em skill do
//encantamento de uma gema
[FUNCTION mage_CalcEnchant]

//Mana inicial
doswitch <ctag0.mage.power>
 local.mana 0
 local.mana 13
 local.mana 20
 local.mana 33
 local.mana 49
 local.mana 65
 local.mana 97
 local.mana 130
 local.mana 195
 local.mana 260
 local.mana 325
ENDDO

//Dif inicial
doswitch <ctag0.mage.power>
 local.dif 0
 local.dif 30
 local.dif 39
 local.dif 43
 local.dif 65
 local.dif 83
 local.dif 96
 local.dif 125
 local.dif 175
 local.dif 200
 local.dif 250
ENDDO

//Custo em skill inicial
doswitch <ctag0.mage.power>
 local.skill 0
 local.skill 0
 local.skill 0
 local.skill 0
 local.skill 0
 local.skill 0
 local.skill 3
 local.skill 7
 local.skill 8
 local.skill 10
 local.skill 50
ENDDO

//Tempo para fazer
doswitch <ctag0.mage.power>
 local.time 0
 local.time 15
 local.time 25
 local.time 35
 local.time 47
 local.time 62
 local.time 78
 local.time 80
 local.time 80
 local.time 80
 local.time 80
ENDDO

IF (<ctag0.mage.enchant_spell>)
 local.dif += <eval <strarg <serv.spell.<ctag.mage.enchant_spell>.skillreq>>/30>
 local.mana += <eval <serv.spell.<ctag.mage.enchant_spell>.MANAUSE>/3>
ENDIF

//Formata texto para gump
local.text=Resumo:<DEF.BR>
if (!<ctag0.mage.power>)
 local.text .= Selecione magia ou bonus.
 return 0
endif
local.text .= <DEF.BFONT_SIZE3><DEF.BFONT_BLACK>Mana: <dlocal.mana><DEF.BR>
local.text .= Dificuldade: <dlocal.dif>.0<DEF.BR>
if (0<local.skill>)
 local.text .= Custo: <fval <local.skill>> <serv.skill.<ctag0.mage_skill>.name><DEF.BR>
endif

IF (<ctag0.mage.enchant_spell>)
 local.resc=<f_count_resources <serv.spell.<ctag0.mage.enchant_spell>.RESOURCES>>
 local.res=<serv.resources.<streat <f_strip_resources 1,<serv.spell.<ctag0.mage.enchant_spell>.RESOURCES>>>.name>
 if (<local.resc> > 1)
  for r 2 <dlocal.resc>
   local.res .=", <serv.resources.<streat <f_strip_resources <dlocal.r>,<serv.spell.<ctag0.mage.enchant_spell>.RESOURCES>>>.name>"
  end
 endif
 local.text .= Reagentes: <local.res>
endif

//Decide se o char pode fazer ou não
local.cando=1
if <ctag0.mage.enchant_spell>
 IF !(<restest <serv.spell.<ctag0.mage.enchant_spell>.RESOURCES>>)
  local.cando=0
 ENDIF
endif
if (!<ctag0.mage.power>)
 local.cando=0
endif

//*************************************************************
// mage_SpellCast <argn1>, <argn2>, <argn3> (do @SpellCast)
//*************************************************************

[COMMENT mage_SpellCast]
IF (<IsGM>)
 return 6
ENDIF
local.skill=<src.<serv.skill.<DEF.<streat <serv.spell.<argn1>.skillreq>>>.key>>
IF <tag0.mage_source>==<DEF.MAGE_SELF>  //Mago castando via WoP
 if !<tag0.mage_know>                   //Não sabe a magia
  argn2=(<argn2>*125)/100
 endif
ELIF <tag0.mage.sournce>==<DEF.MAGE_SCROLL>//Mago castando via scroll
 if <tag0.mage_know>                                                            //Sabe a magia
  serv.log sabe a spell
  argn2=(<strarg <serv.spell.<argn1>.skillreq>>*10)/125                         //Bônus de 25%
 elif (<inscription> > <local.skill>)   //Não sabe a magia. Usar Inscription?
  if (<skillcheck inscription <eval <strarg <serv.spell.<argn1>.skillreq>>/10>>)
   argn2=0      //Passou no teste com inscription
  else
   argn2=1500   //Não passou no teste de inscription
  endif
 else
  serv.log nao sabe a spell
  argn2=<eval <strarg <serv.spell.<argn1>.skillreq>>/10>        //Barra a diff hard coded de t_scroll
 endif
ENDIF
tag.mage_actdiff=<argn2>
serv.log SPELLCAST s: <argn1> (<serv.spell.<argn1>.name>) - d: <argn2> - ad: <argn3> - actdiff: <dtag.mage_actdiff>
return 6

//*************************************************************
// mage_SpellSelect <argn1>, <argn2>, <argn3> (do @SpellSelect)
//*************************************************************

[COMMENT mage_SpellSelect]
IF (<IsGM>)
 return 6//Proceder como o de normal
ENDIF
IF (<tag0.mage_spellid>) && (<argn3>=2)//Foi cancelada e começada outra magia posteriormente?
 mage_cleartags
 argn3=3        //Começar a castar de novo
 return 6
ENDIF
IF (<argn3>==2)         //sucesso. Passar para @skillsuccess
 return 6
ENDIF

//Guarda se o char sabe a spell e quam é a spell
tag.mage_know=<mage_knowSpell <argn1>>
tag.mage_spellid=<argn1>

//Define bônus/penalidade por modalidade de cast (WoP, wand/orb, scroll)
if (<argo>==<uid>)      //Mago castando sozinho
 tag.mage_source=<DEF.MAGE_SELF>
 if !(<tag0.mage_know>)
  argn2=(<argn2>*125)/100       //consimir 25% mais de mana
 endif
else
 tag.mage_uid=<argo>            //Salva item
 argn2=0                        //Castando por item. Não usar mana.
 if (<argo.type>==t_wand)//Mago castando por varinha ou gema
  tag.mage_source=<DEF.MAGE_WAND>
 else
  if (<argo.type>==t_SCROLL)//Mago castando por pergaminho
   tag.mage_source=<DEF.MAGE_SCROLL>
   if (!<tag0.mage_know>)//Se mago não sabe magia do pergaminho, gasta mana.
    argn2=<serv.spell.<argn1>.manause>
   endif
  endif
 endif
endif
IF (<Mana> < <argn2>)
 sysmessageyellow Falta-lhe mana suficiente para esta magia...
 return 1
endif
tag.mage_mana=<argn2>
serv.log SPELLSELECT <argn1> (<serv.spell.<argn1>.name>) - <argn2>
return 6

//////////////////////////////////////TYPEDEFS///////////////////////////////

[TYPEDEF t_scroll]
on=@Dropon_item
IF (<argo.type>==t_spellbook) || (<argo.type>==t_spellbook_necro) || (<argo.type>==t_spellbook_arcanist) || (<argo.type>==t_spellbook_pala) || (<argo.type>==t_wand)
 src.sysmessageyellow Use a skill Inscription para aprender uma magia a partir de um pergaminho
 return 1
endif

[TYPEDEF t_grimorio]
//compatibilidade com sistema de vendas
on=@dclick
if (<link>==04fffffff) || (!<link.instances>)
 //livro sem dono
 if (<src.uid>==<topobj>)
  link=<src.uid>
  src.sysmessageorange Este <name> agora pertence a voce.
 endif
endif
src.mage_loadSpells
src.cTAG.MAGE_GRIMORIO=<uid>
return 0
 

[ITEMDEF i_grimorio_destruicao]
id=i_spellbook
name=grimorio de destruicao
type=t_grimorio
CATEGORY=MyT - Provisions - Alchemy & Magic
SUBSECTION=Magical Items
DESCRIPTION=destruicao

on=@dclick
src.ctag.mage_skill=skill_magery
src.DIALOG d_spellbook 1
return 1

[ITEMDEF i_grimorio_necro]
id=i_spellbook_necromancy
name=grimorio de necromancia
type=t_grimorio
CATEGORY=MyT - Provisions - Alchemy & Magic
SUBSECTION=Magical Items
DESCRIPTION=necromancia

on=@dclick
src.ctag.mage_skill=skill_necromancy
src.DIALOG d_spellbook 1
return 1

[ITEMDEF i_grimorio_restauracao]
id=i_spellbook_paladin
name=grimorio de restauracao
type=t_grimorio
CATEGORY=MyT - Provisions - Alchemy & Magic
SUBSECTION=Magical Items
DESCRIPTION=restauracao

on=@dclick
src.ctag.mage_skill=skill_focus
src.DIALOG d_spellbook 1
return 1

[ITEMDEF i_grimorio_alteracao]
id=i_spellbook_arcanist
name=grimorio de alteracao
type=t_grimorio
CATEGORY=MyT - Provisions - Alchemy & Magic
SUBSECTION=Magical Items
DESCRIPTION=alteracao

on=@dclick
src.ctag.mage_skill=skill_spellweaving
src.DIALOG d_spellbook 1
return 1


[FUNCTION mage_DrawBookPage]
IF (<ctag0.mage_property>==<DEF.MAGE_KNOWN>)
 DB.QUERY="SELECT spellid FROM spellbooks WHERE player='<DB.ESCAPEDATA <UID.<cTAG0.MAGE_GRIMORIO>.link>>' AND skill='<DB.ESCAPEDATA <ctag.mage_skill>>' ORDER BY diff ASC LIMIT <eval (<ctag.mage_page>-1)*2>, 3;"
 local.spell1=<DB.ROW.0.spellid>
 local.spell2=<DB.ROW.1.spellid>
 local.nextpage=<QVAL <DB.ROW.NUMROWS>==3?1:0>
ELIF (<ctag0.mage_property>==<DEF.MAGE_LEARNING>)
 call src.mage_GetLearningSpells
ENDIF

//Pagina esquerda
button 49 9 2205 2205 1 0 1002
IF (<eval <local.spell1>>)
 dhtmlgump 82 8 112 35 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE><serv.spell.<local.spell1>.name>//Nome da magia
 if (!<IsEmpty <src.ctag.mage_action>>)//Se é necessário apertar a runa pra fazer alguma coisa (inscription, etc)
  button 65 46 2472 2473 1 0 <eval <DEF.<local.spell1>>&~0ca000000>
 endif
 gumppic 60 41 <serv.spell.<local.spell1>.RUNE_ITEM>// //Runa
 dhtmlgump 107 41 88 41 0 0 <DEF.BFONT_SIZE4><mage_GetSpellRunes <local.spell1>>//WoP
 gumppictiled 71 83 104 21 58//Separador de barra
 //Pega os reags da lista e transforma em nomes. As função são do cictema_de_facas_especiais.scp
 local.resc=<f_count_resources <serv.spell.<local.spell1>.RESOURCES>>
 local.res=<serv.resources.<streat <f_strip_resources 1,<serv.spell.<local.spell1>.RESOURCES>>>.name>
 if (<local.resc> > 1)
  for r 2 <dlocal.resc>
   local.res .=", <serv.resources.<streat <f_strip_resources <dlocal.r>,<serv.spell.<local.spell1>.RESOURCES>>>.name>"
  end
 endif
 dhtmlgump 57 90 142 70 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE>Reagentes:<DEF.BR><DEF.BFONT_SIZE3><DEF.BFONT_BLACK><local.res>//reagentes
 IF (<local.spell1_rest>)       //Se está aprendendo, mostrar quanto falta
  dhtmlgump 57 160 140 35 0 0 <DEF.BFONT_SIZE2><DEF.BFONT_DBLUE>Restam <eval <mage_getIncLearning <local.spell1>>-<dlocal.spell1_rest>> tentativas e <f_timestring <local.spell1_time>>
 ELSE
  dhtmlgump 57 160 140 42 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE>Mana:      <eval <serv.spell.<local.spell1>.MANAUSE>><DEF.BR>Dificuldade:  <eval <strarg <serv.spell.<local.spell1>.skillreq>>/10>
 ENDIF
ENDIF

//Pagina direita
IF (<eval <local.spell2>>)
 dhtmlgump 212 8 112 35 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE><serv.spell.<local.spell2>.name>
 if (!<IsEmpty <src.ctag.mage_action>>)//Se é necessário apertar a runa pra fazer alguma coisa (inscription, etc)
  button 225 46 2472 2473 1 0 <eval <DEF.<local.spell2>>&~0ca000000>
 endif
 gumppic 220 41 <serv.spell.<local.spell2>.RUNE_ITEM>//gumppic 60 41 2240
 dhtmlgump 267 41 88 41 0 0 <DEF.BFONT_SIZE4><mage_GetSpellRunes <local.spell2>>
 gumppictiled 231 83 104 21 58
 //Pega os reags da lista e transforma em nomes. As função são do cictema_de_facas_especiais.scp
 local.resc=<f_count_resources <serv.spell.<local.spell2>.RESOURCES>>
 local.res=<serv.resources.<streat <f_strip_resources 1,<serv.spell.<local.spell2>.RESOURCES>>>.name>
 if (<local.resc> > 1)
  for r 2 <dlocal.resc>
   local.res .=", <serv.resources.<streat <f_strip_resources <dlocal.r>,<serv.spell.<local.spell2>.RESOURCES>>>.name>"
  end
 endif
 dhtmlgump 217 90 142 70 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE>Reagentes:<DEF.BR><DEF.BFONT_SIZE3><DEF.BFONT_BLACK><local.res>
 IF (<local.spell2_rest>)       //Se está aprendendo, mostrar quanto falta
  dhtmlgump 217 160 140 35 0 0 <DEF.BFONT_SIZE2><DEF.BFONT_DBLUE>Restam <eval <mage_getIncLearning <local.spell2>>-<dlocal.spell2_rest>> tentativas e <f_timestring <local.spell2_time>>
 ELSE
  dhtmlgump 217 160 140 42 0 0 <DEF.BFONT_SIZE5><DEF.BFONT_DBLUE>Mana:      <eval <serv.spell.<local.spell2>.MANAUSE>><DEF.BR>Dificuldade:  <eval <strarg <serv.spell.<local.spell2>.skillreq>>/10>
 ENDIF
ENDIF

IF (<local.nextpage>)
 button 321 8 2206 2206 1 0 1003
endif

[FUNCTION mage_GetLearningSpells]
local.i=0
obj=<src.uid>
FORCONTID i_mry_learn_spell
 IF STRMATCH(<streat <serv.spell.<more1>.skillreq>>,<obj.ctag.mage_skill>)
  IF (<eval (<obj.ctag.mage_page>-1)*2>==<local.i>)
   local.spell1=<more1>
   local.spell1_rest=<more2>
   local.spell1_time=<timer>
  ELIF (<eval (<obj.ctag.mage_page>-1)*2>==<local.i>-1)
   local.spell2=<more1>
   local.spell2_rest=<more2>
   local.spell2_time=<timer>
  ELIF (<eval (<obj.ctag.mage_page>-1)*2>==<local.i>-2)
   local.nextpage=1
  ENDIF
  local.i += 1
 ENDIF
END


[DIALOG d_spellbook]
100,150
page 0
button 6 104 2103 2103 1 0 0
if (<src.ctag.mage_skill>==skill_magery)
 gumppic 0 0 2220
elif (<src.ctag.mage_skill>==skill_necromancy)
 gumppic 0 0 11008
elif (<src.ctag.mage_skill>==skill_spellweaving)
 gumppic 0 0 11055
elif (<src.ctag.mage_skill>==skill_focus)
 gumppic 0 0 11009
endif
page 1
dtext 75 16 48 Tomo de magias
gumppictiled 72 102 100 10 50
dhtmlgump 59 115 125 74 0 0 <DEF.center>Propriedade de <uid.<uid.<cTAG.MAGE_GRIMORIO>.link>.tag.name>
if (<UID>==<uid.<cTAG.MAGE_GRIMORIO>.link>)
 dhtmlgump 215 35 200 25 0 0 Magias sendo aprendidas
 button 266 57 2472 2473 1 0 1000
endif
gumppictiled 229 102 100 10 50
button 266 147 2472 2473 1 0 1001
dhtmlgump 232 128 125 25 0 0 Magias conhecidas
page 2
mage_DrawBookPage

page 3
dhtmlgump 57 13 125 29 0 0 <DEF.CENTER><DEF.BFONT_SIZE1><uid.<ctag0.mage.gem>.name>
tilepic 95 49 <uid.<ctag0.mage.gem>.dispiddec>
button 56 110 250 251 1 0 1004          //Mais poder
button 56 130 252 253 1 0 1005          //Menos poder
dtext 79 120 43 +<dctag0.mage.power> <QVAL <ctag0.mage.enchant_spell>?cargas:<serv.skill.<ctag0.mage_skill>.name>>
button 54 167 2224 2224 1 0 1006        //Adicionar/remover magia
dhtmlgump 74 164 114 20 0 0 <QVAL <ctag0.mage.enchant_spell>?<serv.spell.<ctag0.mage.enchant_spell>.name>:Adicionar magia>
CALL mage_CalcEnchant           //Calcula o custo
dhtmlgump 218 12 130 157 0 0 <local.text>
IF (<local.cando>)
 button 250 171 247 248 1 0 1007                //Botão Encantar
endif

[DIALOG d_spellbook text]


[DIALOG d_spellbook button]
ON=0
// Button 1
src.ctag.mage_property=
src.ctag.mage_page=
src.ctag.mage_skill=
src.ctag.mage_action=

ON=1 999
//Faz o mago executar a função <ctag.mage_action> com <argv[0]> da magia selecionada
src.try <src.ctag.mage_action> <argn>
src.ctag.mage_action=

ON=1000
// learning spells
src.ctag.mage_property=<DEF.MAGE_LEARNING>
src.ctag.mage_page=1
src.DIALOG d_spellbook 2

ON=1001
// known spells
src.ctag.mage_property=<DEF.MAGE_KNOWN>
src.ctag.mage_page=1
src.DIALOG d_spellbook 2

ON=1002
// pg-
src.ctag.mage_page=<src.ctag0.mage_page>-1
IF (!<src.ctag0.mage_page>)
 src.ctag.mage_property=
 src.DIALOG d_spellbook 1
ELSE
 src.DIALOG d_spellbook 2
ENDIF

ON=1003
// pg+
src.ctag.mage_page=<src.ctag0.mage_page>+1
src.DIALOG d_spellbook 2

ON=1004
//Mais poder
IF (<ctag0.mage.power> < 10)
 ctag.mage.power=<ctag0.mage.power>+1
endif
DIALOG d_spellbook 3
return 1

ON=1005
//Menos poder
IF (<ctag0.mage.power> > 0)
 ctag.mage.power=<ctag0.mage.power>-1
endif
DIALOG d_spellbook 3
return 1

ON=1006
//Add/Rem magia
IF (!<ctag0.mage.enchant_spell>)
 ctag.mage_action=mage_enchant_gem_select_spell         //Função que vai ser chamada quando a magia for selecionada
 ctag.mage_property=<DEF.MAGE_KNOWN>            //Abrir o livro na parte de magias conhecidas
 ctag.mage_page=1                               //Abrir o livro na página 1
 DIALOG d_spellbook 2                           //Abrir o livro
 sysmessagegreen Selecione uma magia conhecida:
else
 ctag.mage.enchant_spell=
 DIALOG d_spellbook 3
endif
return 1

ON=1007
//Okay
sysmessageyellow Voce comeca o encantamento.
call mage_CalcEnchant
obj=<findid.i_faz_item>
obj.cleartags
obj.tag.delay=<local.time>
obj.tag.skill=<serv.skill.<ctag0.mage_skill>.name>
obj.tag.skill2=<local.skill>
obj.tag.dif=0
obj.tag.dif2=<local.dif>
obj.tag.mana=<local.mana>
obj.tag.spell=<ctag0.mage.enchant_spell>
obj.tag.power=<ctag0.mage.power>
obj.tag.f_step=mage_enchant_gem_step
obj.tag.item=1
obj.tag.f_done=mage_enchant_gem_end
obj.tag.abort=1
src.fazitem
sfx=05c1
return 1

[FUNCTION mage_enchant_gem_step]
DORAND 5
 anim=17
ENDDO
DORAND 10
 BEGIN
  EFFECT 1 0 0 16 0
  SFX <hval <DEF.SND_THUNDER>>
 ENDDO
 EFFECT 3 i_fx_sparkle 0 32 0
ENDDO
DORAND 10
 sfx 01f7
 sfx 01EB
ENDDO
//Manter caldeirao certinho
IF !<R0,5>
 foritems 2
  if (<defname>==i_bowl_stew) && (<more2>==5)
   more1=120
  elif (<defname>==i_campfire)
   timer=120
  endif
 end
endif

[FUNCTION mage_enchant_gem_end]
//Determina se esta num altar
if (STRMATCH(*_altar_magi*,<dspeech>))
 local.can=<mage_enchant_altar_test_users>
else
 local.caldronOK=0
 obj=<UID>
 foritems 2
  if (<type>==t_stew) && (<more2>==5)
   local.can=<obj.mage_enchant_caldron_test>
   more1=1
  endif
 end
endif
if (<local.can>)
 sfx 05c2
 make_chanted_gem
else
 sfx 0274
 sysmessagered Voce falhou ao tentar encantar a pedra.
endif

[FUNCTION make_chanted_gem]
obj=<ctag.mage.gem>
//A gema ainda existe?
if (<obj.amount> > 1) || (<obj.topobj>!=<UID>) || (!<obj.uid>)
 damage 30,<DEF.dam_god>,<UID>
 sysmessagered Voce tentou perturbar o Eter!
 EFFECT 1 0 0 16 0
 SFX <hval <DEF.SND_THUNDER>>
 return 1
endif
//Pedra lapidada virando gema?
if (<obj.tdata2>)
 newitem <obj.tdata2>
 new.bounce
 obj.decrement
 obj=<new>
else
 //Gema sendo encantada?
 obj.name=Gema de <strarg <obj.name>>
endif
obj.more2=<ctag0.mage.power>            //Adiciona cargas ou bônus
obj.attr=021                            //identifyed and magic
//Vai colocar uma magia nela?
if (<ctag0.mage.enchant_spell>)
 obj.type=t_wand                        //Troca o type para trigar magia 
 obj.morex=<ctag0.mage.enchant_spell>   //Guarda a magia
endif
obj.updatex                             //Troca ToolTip
sysmessagegreen Voce encantou uma <obj.name> com sucesso! 
mage_cleartags

[FUNCTION mage_enchant_caldron_test]
serv.log [ENCANTAMENTO] Usando caldeirao: <tag.name> (<account> - <uid>) encantando <ctag0.mage.gem> (<uid.<ctag0.mage.gem>.name>)
obj=<findid.i_mry_fazitem>
local.dif=<obj.tag.dif2>
local.skill=<obj.tag.skill>
serv.log [ENCANTAMENTO] <local.skill>: <dlocal.dif>

//Determina custos
local.mana=<obj.tag.mana>
local.cost=<obj.tag.skill2>
serv.log [ENCANTAMENTO] mana: <dlocal.mana> (Custa <dlocal.cost> <local.skill>)

//consome mana e skill do mago e testa a skill
local.manaOK=1
local.skillOK=1

IF (<mage_consumeMana <local.mana>>)
 local.manatest=1
ELSE
 local.manatest=0
ENDIF
local.manaOK=<local.manaOK>&<local.manatest>
local.test=<eval ( (<alchemy>*2) + (<uid.<uid>.<local.skill>>*8) )/10>
local.skillOK=<local.skillOK>&<belltest <local.test>,<eval <local.dif>*10>>
if (<local.cost>)
 try UID.<uid>.<local.skill> = <UID.<uid>.<local.skill>>-<local.cost>
 skill_init
endif
serv.log [ENCANTAMENTO] TESTE skill: <dlocal.skillOK> - mana:<dlocal.manaOK>

//precisa testar reags da magia?
local.reagsOK=1
if (<ctag0.mage.enchant_spell>)
 if (<restest <serv.spell.<ctag0.mage.enchant_spell>.resources>>)
  consume <serv.spell.<ctag0.mage.enchant_spell>.resources>
 else
  local.reagsOK=0
 endif
endif

IF (<local.manaOK> && <local.skillOK> && <local.reagsOK>)
 return 1
else
 return 0
endif

[FUNCTION mage_enchant_altar_test_users]
serv.log [ENCANTAMENTO] Usando altar: <tag.name> (<account> - <uid>) encantando <ctag0.mage.gem> (<uid.<ctag0.mage.gem>.name>)

//Determina o número de participantes
ref1=<region.uid>
local.users=1
for u 2 8
 if (<ref1.tag0.user_<dlocal.u>>)
  local.users += 1
 endif
end
serv.log [ENCANTAMENTO] <dlocal.users> usuarios no altar

//Determina o teste de skill para cada membro
obj=<findid.i_mry_fazitem>
local.actdif=<obj.tag.dif2>
local.skill=<obj.tag.skill>
local.dif=<eval <local.actdif>/<local.users>>
serv.log [ENCANTAMENTO] <local.skill>: <dlocal.actdif> (<dlocal.dif> para cada)

//Determina custos para cada membro
local.mana=<eval <obj.tag.mana>/<local.users>>
local.cost=<obj.tag.skill2>
serv.log [ENCANTAMENTO] mana: <dlocal.mana> (Custa <eval <local.cost>/<local.users>> <local.skill> para cada)

//consome mana e skill dos envolvidos e testa a skill
local.manaOK=1
local.skillOK=1
for u 1 <local.users>
 if (<UID.<ref1.tag0.user_<dlocal.u>>.ischar>)
  IF (<UID.<ref1.tag0.user_<dlocal.u>>.mage_consumeMana <local.mana>>)  //QVAL não suportado aqui
   local.manatest=1
  ELSE
   local.manatest=0
  ENDIF
  local.manaOK=<local.manaOK>&<local.manatest>
  local.test=<eval <UID.<ref1.tag0.user_<dlocal.u>>.<local.skill>>>
  local.skillOK=<local.skillOK>&<UID.<ref1.tag0.user_<dlocal.u>>.belltest <local.test>,<eval <local.dif>*10>>
  if (<local.cost>)
   try UID.<ref1.tag0.user_<dlocal.u>>.<local.skill> = <UID.<ref1.tag0.user_<dlocal.u>>.<local.skill>>-<eval <local.cost>/<local.users>>
   UID.<ref1.tag0.user_<dlocal.u>>.skill_init
  endif
  serv.log [ENCANTAMENTO] TESTE DO MAGO No <dlocal.u> :: skill: <dlocal.skillOK> - mana:<dlocal.manaOK>
 endif
end

//precisa testar reags da magia?
local.reagsOK=1
if (<ctag0.mage.enchant_spell>)
 if (<restest <serv.spell.<ctag0.mage.enchant_spell>.resources>>)
  consume <serv.spell.<ctag0.mage.enchant_spell>.resources>
 else
  local.reagsOK=0
 endif
endif

IF (<local.manaOK> && <local.skillOK> && <local.reagsOK>)
 return 1
else
 return 0
endif


[FUNCTION mage_register_altar_user]
obj=<UID>
for u 1 8
 if (<isEmpty <obj.tag.user_<dlocal.u>>>)
  try obj.tag.user_<dlocal.u>=<argn>
  return 1
 endif
end

[FUNCTION mage_UNregister_altar_user]
obj=<UID>
for u 1 8
 serv.log Usuario <dlocal.u>=<obj.tag0.user_<dlocal.u>>
 if (<obj.tag0.user_<dlocal.u>>==<argn>)
  try obj.tag.user_<dlocal.u>=
  return 1
 endif
end

[REGIONTYPE r_altar_magic]
on=@enter
src.sysmessageblue Voce sente uma aura magica.
src.dspeech +spk_altar_magic
uid.<uid>.mage_register_altar_user <src.uid>
src.music=<hval <DEF.musics_dungeon>>

on=@exit
src.sysmessageyellow Voce nao sente mais magia.
uid.<uid>.mage_UNregister_altar_user <src.uid>
src.dspeech -spk_altar_magic

[SPEECH spk_altar_magic]
on=Chantus Maliki
obj=<region.uid>
if (<obj.tag0.user_1>==<src.uid>)
 src.mage_enchant_gem
else
 src.sysmessageorange <src.rec_fgetname <obj.tag0.user_1>> esta no comando do altar.
 return 1
endif























//#################################################################################

//                              ITENS DE TESTE

//#################################################################################

[TYPEDEF t_spell_test_cont]
//Gera <more1> amt de cada pergaminho das magias nº [<morex>:<morey>]
//A cada <morez> minutos
on=@dclick
if (<eval (<serv.time>-<more2>)/600> > <morez>)
 more2=<serv.time>
 empty
 for s <morex> <morey>
  if (<serv.spell.<local.s>>)
   serv.newitem <serv.spell.<local.s>.SCROLL_ITEM>
   new.cont=<uid>
   new.amount=<more1>
  else
   serv.log [CAIXA DE TESTE DE MAGIA] - <dlocal.s> nao eh magia.
  endif
 end
 update
endif

[ITEMDEF i_bau_teste_destruicao]
NAME=Pergaminhos de destruicao
ID=i_chest_metal
TYPE=T_CONTAINER
FLIP=1
WEIGHT=20
TEVENTS=t_spell_test_cont

on=@create
color=028
more1=20
more2=0
morex=100
morey=119
morez=60

[ITEMDEF i_bau_teste_restauracao]
NAME=Pergaminhos de restauracao
ID=i_chest_metal
TYPE=T_CONTAINER
FLIP=1
WEIGHT=20
TEVENTS=t_spell_test_cont

on=@create
color=0809
more1=20
more2=0
morex=150
morey=169
morez=60

[ITEMDEF i_bau_teste_alteracao]
NAME=Pergaminhos de alteracao
ID=i_chest_metal
TYPE=T_CONTAINER
FLIP=1
WEIGHT=20
TEVENTS=t_spell_test_cont

on=@create
color=017C
more1=20
more2=0
morex=250
morey=269
morez=60


[ITEMDEF i_stone_skill]
ID=0eDD
NAME=Pedra de teste de skill
TYPE=t_script

on=@dclick
src.menu m_test_skill
return 1

[MENU m_test_skill]
O que deseja fazer agora? (sujeito a apenas uma subida de skill a cada 3 horas)

ON=0 Subir 12.5 em uma skill
src.test_skill_up

ON=0 Descer 12.5 em uma skill
src.test_skill_dn

[FUNCTION test_skill_up]
if (<tag0.skill_test_time>)
 local.eltime=<hval <serv.time>-<tag0.skill_test_time>>
 local.extime=<hval <local.eltime>-10*60*60*3>
 if (<local.extime> < 0)
  sysmessagered Voce deve esperar mais <f_timestring <eval -<local.extime>/10>> para subir novamente uma skill.
  return 1
  endif
endif
list_new Escolha uma skill para subir 12.5 pontos:
list_newCol 20,Skill
cTAG.list_action=test_skill_apply_up
cTAG.list_numItems=54
cTAG.list_numPages=4
for s 0 54
 try cTAG.list_row<local.s>_01=<serv.skill.<local.s>.name>
end
list_show 1

[FUNCTION test_skill_dn]
list_new Escolha uma skill para descer 12.5 pontos:
list_newCol 20,Skill
cTAG.list_action=test_skill_apply_dn
cTAG.list_numItems=54
cTAG.list_numPages=4
for s 0 54
 try cTAG.list_row<local.s>_01=<serv.skill.<local.s>.name>
end
list_show 1

[FUNCTION test_skill_apply_up]
src.<argn> += 125
src.tag.skill_test_time=<serv.time>
src.sysmessageyellow Voce podera utilizar este comando novamente em 3 horas.

[FUNCTION test_skill_apply_dn]
src.<argn> -= 125
[EOF]
