[DEFNAME administrative_constants]
SM_RED=028
SM_GREEN=044
SM_BLUE=04
SM_YELLOW=036
SM_ORANGE=02c
SND_GLASS={{03e 041} 1 {038d 0390} 1}
SND_THUNDER={05CE 1 028 1 029 1 0206 1}

[PLEVEL 6]
f_connectDB

//*****************************************************************************
//*****************************************************************************
// FUNCOES
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
// f_oncommand( )
//*****************************************************************************
[FUNCTION f_oncommand]
if strmatch("<args>","xresurrect")
    src.sysmessagered Utilize xress
    return 1
elif (strmatch(hungry,<args>))
    comida
    return 1
endif

//*****************************************************************************
// f_connectDB( )
//*****************************************************************************
[FUNCTION f_connectDB]
DB.CONNECT
if (<DB.CONNECTED>)
    SERV.log MySQL debug: MySQL successfully connected!
else
    SERV.log MySQL debug: MySQL not connected!
endif


//*****************************************************************************
// f_sendMessage( uidPlayer, message, msgColor )
//*****************************************************************************
//envia mensagem para um player online. se estiver offline a mensagem é armazenada no banco
//e entregue no proximo login.
//
// ARGV[0] --> UID destino
// ARGV[1] --> mensagem
// ARGV[2] --> cor (SM_RED,SM_GREEN...etc)
[FUNCTION f_sendMessage]
    
//save OBJ ref.
    LOCAL.obj=<OBJ>
    
    OBJ=<argv[0]>
    if ( <OBJ.isonline> )
        OBJ.sysmessage @<argv[2]> <argv[1]>
    else
        if ( <DB.connected> )
            DB.EXECUTE "INSERT INTO messageBox SET timestamp=NOW(), message='<argv[1]>', status='Pending', triggerUid=<eval <SRC.uid>>, toUid=<eval <argv[0]>>, color=<eval <argv[2]>>"
        endif
    endif
    
    OBJ=<LOCAL.obj>
    
//*****************************************************************************
// f_deliverPendingMessages( )
//*****************************************************************************
//chame essa funcao no login para enviar as mensagens pendentes ao player.  
//SRC é o player fazendo login
[FUNCTION f_deliverPendingMessages]
if ( <DB.connected> )
    DB.QUERY "SELECT message,color FROM messageBox WHERE status='Pending' AND toUid=<eval <SRC.uid>>"
    if (<DB.ROW.NUMROWS> > 0)
        for R 0 <eval <DB.ROW.NUMROWS>-1>
            SRC.sysmessage @<DB.ROW.<eval <LOCAL.R>>.color> <DB.ROW.<eval <LOCAL.R>>.message>
        end
        DB.EXECUTE "UPDATE messageBox SET status='Sent' WHERE toUid=<eval <SRC.uid>>"
    endif
endif
    

//*****************************************************************************
// f_isWeapon( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeapon]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_axe )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_sharp )
        return 1
    elif ( <LOCAL.type>==t_weapon_sword )
        return 1
    elif ( <LOCAL.type>==t_weapon_fence )
        return 1
    elif ( <LOCAL.type>==t_weapon_bow )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <LOCAL.type>==t_weapon_arrow )
        return 1
    elif ( <LOCAL.type>==t_weapon_bolt )
        return 1
    elif ( <LOCAL.type>==t_weapon_xbow )
        return 1
    elif ( <LOCAL.type>==t_string )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isWeaponTool( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeaponTool]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <uid.<argn>.id>==0F51 ) || ( <uid.<argn>.id>==0EC4 ) || ( <uid.<argn>.id>==013F6 ) || ( <uid.<argn>.id>==0EC2 )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isArmor( item )
//*****************************************************************************
//retorna 1 se o argumento for uma armadura (ou escudo)
[FUNCTION f_isArmor]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_armor )
        return 1
    elif ( <LOCAL.type>==t_armor_leather )
        return 1
    elif ( <LOCAL.type>==t_shield )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRegsOrMagic( item )
//*****************************************************************************
//retorna 1 se o argumento for uma reagente ou magico
[FUNCTION f_isRegsOrMagic]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_wand )
        return 1
    elif ( <LOCAL.type>==t_potion )
        return 1
    elif ( <LOCAL.type>==t_potion_empty )
        return 1
    elif ( <LOCAL.type>==t_reagente )
        return 1
    elif ( <LOCAL.type>==t_almofariz )
        return 1
    elif ( <LOCAL.type>==t_espiriteira )
        return 1
    elif ( <LOCAL.type>==t_destilador )
        return 1
    elif ( <LOCAL.type>==t_balao )
        return 1
    elif ( <LOCAL.type>==t_misturador )
        return 1
    elif ( <LOCAL.type>==t_tubo )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isFood( item )
//*****************************************************************************
//retorna 1 se o argumento for um alimento/comestivel
[FUNCTION f_isFood]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_food )
        return 1
    elif ( <LOCAL.type>==t_food_raw )
        return 1
    elif ( <LOCAL.type>==t_fish )
        return 1
    elif ( <LOCAL.type>==t_fruit )
        return 1
    elif ( <LOCAL.type>==t_meat_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isMisc( item )
//*****************************************************************************
//retorna 1 se o argumento for ferramenta, movel, etc
[FUNCTION f_isMisc]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clock )
        return 1
    elif ( <LOCAL.type>==t_termometro )
        return 1
    elif ( <LOCAL.type>==t_musical )
        return 1
    elif ( <LOCAL.type>==t_ar_projeto )
        return 1
    elif ( <LOCAL.type>==t_ar_livro )
        return 1
    elif ( <LOCAL.type>==t_carpentry )
        return 1
    elif ( <LOCAL.type>==t_chair )
        return 1
    elif ( <LOCAL.type>==t_sextant )
        return 1
    elif ( <LOCAL.type>==t_table )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_shaft )
        return 1
    elif ( <LOCAL.type>==t_tinker_tools )
        return 1
    elif ( <LOCAL.type>==t_carpentry_tool )
        return 1
    elif ( <LOCAL.type>==t_cooking_tool )
        return 1
    elif ( <LOCAL.type>==t_bancada )
        return 1
    elif ( <LOCAL.type>==t_light_out )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_oleo )
        return 1
    elif ( <LOCAL.type>==t_book )
        return 1
    elif ( <LOCAL.type>==t_sand )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_buy_misc )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_luz_oleo )
        return 1        
    elif ( <LOCAL.type>==t_container )
        return 1        
    else
        return 0
    endif

//*****************************************************************************
// f_isWearable( item )
//*****************************************************************************
//retorna 1 se o argumento for roupas, joias, etc
[FUNCTION f_isWearable]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clothing )
        return 1
    elif ( <LOCAL.type>==t_cloth )
        return 1
    elif ( <LOCAL.type>==t_tailoring )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_jewelry )
        return 1
    elif ( <LOCAL.type>==t_bandagem )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRaw( item )
//*****************************************************************************
//retorna 1 se o argumento for materia prima
[FUNCTION f_isRaw]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_log )
        return 1
    elif ( <LOCAL.type>==t_ore )
        return 1
    elif ( <LOCAL.type>==t_ingot )
        return 1
    elif ( <LOCAL.type>==t_seed )
        return 1
    elif ( <LOCAL.type>==t_leather )
        return 1
    elif ( <LOCAL.type>==t_loom )
        return 1
    elif ( <LOCAL.type>==t_feather )
        return 1
    elif ( <LOCAL.type>==t_wool )
        return 1
    elif ( <LOCAL.type>==t_fur )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_cotton )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_buy_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_hide )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// wipeObject <DEFNAME> Remove todos os itens <DEFNAME> do world.
//*****************************************************************************
[FUNCTION wipeObject]
IF !(<ARGN>)
 IF (<ISEMPTY <DEF.<ARGS>>>)
  SYSMESSAGE <args> nao existe.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGS>>)
 IF !(<SERV.ITEMDEF.<ARGS>>) && !(<SERV.CHARDEF.<ARGS>>)
  SYSMESSAGE <ARGS> nao eh um item nem criatura.
  RETURN 0
 endif
 FORINSTANCES <argv[0]>
  LOCAL.wipe=<local.wipe>+1
  remove
 ENDFOR
 if (<IsGM>)
  sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.RESOURCES.<argv[0]>.NAME>
 endif
endif

//*****************************************************************************
//  CRY Faz o char gritar de dor e animar (compatibilidade com 55i)
//*****************************************************************************

[FUNCTION cry]
//// anima
anim 20                     //Animação de @GetHit
bark 3

//*****************************************************************************
//  EFFECTSPELL <spell>,<skill>
//*****************************************************************************
//Retorna o EFFECT de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION EFFECTSPELL]
if (<isitem>)
    return 1
endif
LOCAL.eff=<SERV.RESOURCES.<argv0>.EFFECT>
LOCAL.skill=<argn1>
LOCAL.min=<strarg <LOCAL.eff>>
LOCAL.eff=<streat <LOCAL.eff>>

//Resisting spells?
if (<serv.resources.<argv0>.FLAGS>&spellflag_resist)
 if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
  sysmessageblue Voce resiste a magia.
  //Resistir totalmente?
  if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
   LOCAL.min=0
   LOCAL.eff=0
   sfx 05C1
   emotered resistiu
  else                      //Resistir parcialmente
   LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
  endif
 endif
 SKILL_GAIN Skill_MagicResistance
endif

LOCAL.eff=<EVAL {<LOCAL.min> <LOCAL.eff>}>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
RETURN <LOCAL.eff>

//*****************************************************************************
//  DAMAGESPELL <spell>,<dam_type>,<skill>,<UIDcaster>
//*****************************************************************************
//Danifica conforme a magia <argv0> com tipo <argv1> como se tivesse magery <argv2> por <<argv3>.UID>
[FUNCTION damagespell]
LOCAL.dam=<EFFECTSPELL <argv0>, <argv2>>
DAMAGE <LOCAL.dam> <EVAL <argv1>> <argv3>                           //aplica o dano com o tipo modificado
RETURN <LOCAL.dam>

//*****************************************************************************
//  IsStonned
//*****************************************************************************
//Retorna se o char está stonnado ou não.
[FUNCTION IsStonned]
if (<restest 1 i_stonned>)
 RETURN 1
else
 RETURN 0
endif

//*****************************************************************************
//  Stonned <tempo>
//*****************************************************************************
//Petrifica um char por <tempo> segundos.
[FUNCTION Stonned]
if (<IsStonned>)
 RETURN 0
endif
serv.newitem i_stonned
new.timer=<argn>
equip <new.uid>
RETURN 1

[ITEMDEF i_stonned]
ID=020A5
NAME=Petrificado
TYPE=t_eq_script
LAYER=layer_special

on=@equip
cont.flags=<cont.flags>|040000
cont.update

on=@timer
cont.flags=<cont.flags>&~040000
cont.sysmessageblue Voce nao esta mais petrificado.
cont.update
remove
RETURN 1

//*****************************************************************************
// emotes
//*****************************************************************************
[FUNCTION emotegreen]
SAY @<DEF.SM_GREEN>,  *<args>*

[FUNCTION emotered]
SAY @<DEF.SM_RED>,  *<args>*

[FUNCTION emoteyellow]
SAY @<DEF.SM_YELLOW>,  *<args>*

[FUNCTION emoteblue]
SAY @<DEF.SM_BLUE>,  *<args>*

[FUNCTION emoteorange]
SAY @<DEF.SM_ORANGE>,  *<args>*

//*****************************************************************************
// sysmessage
//*****************************************************************************
[FUNCTION sysmessagered]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_RED>,3  <args>
endif

[FUNCTION sysmessageblue]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_BLUE>,3  <args> 
endif

[FUNCTION sysmessagegreen]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_GREEN>,3  <args> 
endif

[FUNCTION sysmessageyellow]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_YELLOW>,3  <args> 
endif

[FUNCTION sysmessageorange]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_ORANGE>,3  <args> 
endif

//*****************************************************************************
// decrement
//*****************************************************************************
[FUNCTION decrement]
amount=<amount>-1
if (<amount><1)
    remove
endif
update

//*****************************************************************************
// f_sendTooltip(title,text)
//*****************************************************************************
[FUNCTION f_sendTooltip]
src.addcliloc 1042971,<argv0>
src.addcliloc 1070722,<argv1>

//*****************************************************************************
// f_sendTooltipData(text)
//*****************************************************************************
[FUNCTION f_sendTooltipData]
src.addcliloc 1070722,<argv0>

//*****************************************************************************
// checkVersion([major],[lower],[minor])
//*****************************************************************************
[FUNCTION checkVersion]
if (!0<argv0>)
    return <f_checkVersion <STREAT <explode .,<CLIENTVERSION>>>>
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
    src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
    return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_checkVersion(major,lower,minor)
//*****************************************************************************
[FUNCTION f_checkVersion]
if (!0<argv0>)
    serv.log Clientversion invalido: <CLIENTVERSION> -- <argv0>::<argv1>::<argv2>
    return 0
endif
if (<argv0>==6) && (<argv1>==0) && (<argv2>==1)
    src.sysmessageyellow ****************************************************Versao de client 6.0.1.7 CAUSA problemas.
    return 1
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_spreadValue(value,error)
//*****************************************************************************
//dado um valor value, retorn um valor aleatorio V+-K, onde K vai de 0 a
//(V/2) (erro 100%)
//'error' deve ser passado entre 0 (retorna 'value') e Cm (atualmente 50)

//Formula e simplificavao:
//Vn=V*[1+(2*Er-Em)/(2*Cm)]
//Vn=V*[(2*Cm)+(2*Er)-Em)]/(2*Cm)
//Vn=V*[K-Em+(2*Er)]/k
//Vn - valor falso
//V  - valor real ('value')
//Cm - Maximo % de erro (0 a 100). Atualmente ajustado em 50.
//Em - Erro máximo ('error')
//Er - Erro random (0 a Em)
[FUNCTION f_spreadValue]
return <eval (<argv0>*((100-<argv1>)+(2*<R0,<argv1>>)))/100>

//*****************************************************************************
// f_rangeValue(min,max,skill)
//*****************************************************************************
//dado um valor value, retorn um valor de acordo com uma regra de tres
//composta entre <min> e <max> de acordo com <skill>
[FUNCTION f_RangeValue]
LOCAL.min=<argv0>
LOCAL.max=<argv1>
LOCAL.skill=<argv2>
LOCAL.max=<LOCAL.max>-<LOCAL.min>
LOCAL.max=((<LOCAL.max>*<LOCAL.skill>)/1000)+<LOCAL.min>
return <eval <LOCAL.max>>

//*****************************************************************************
// f_isDisturbed()
//*****************************************************************************
//verifica se ha algum flag de perturbacao:
//statf_hallucinating|statf_fly|statf_stone|statf_polymorph|statf_war|statf_sleeping|statf_freeze|statf_dead
[FUNCTION f_isDisturbed]
if (<flags>&000540436)
    return 1
endif
return 0

//*****************************************************************************
// f_gmLog( text )
//*****************************************************************************
//exibe sysmensage para gms dentro da area da tela SOMENTE se var.gmlog estiver 
//ativo
[FUNCTION f_gmLog]
if (!<var0.gmlog>)
    return
endif
FORCLIENTS
    if (<gm>)
        sysmessageyellow <args>
    endif
ENDFOR


//*****************************************************************************
// f_npcRunStepToUid( [uid_to_go], steps,[px,py]  )
//*****************************************************************************
//npc corre em dire  o ao UID
//default: NPC que ira correr
//uid_to_go: uid alvo
//steps numero de 'run's que ira dar em direcao ao alvo
[FUNCTION f_npcRunStepToUid]
REF1=<argv0>
if (<REF1>)
    LOCAL.dx = <eval <REF1.p.x>-<p.x>>
    LOCAL.dy = <eval <REF1.p.y>-<p.y>>
else
    LOCAL.dx = <eval <argv2>-<p.x>>
    LOCAL.dy = <eval <argv3>-<p.y>>
endif

LOCAL.run=0
if ( <LOCAL.dx> > 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SE
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NE
       else
               LOCAL.run=E
       endif
elif ( <LOCAL.dx> < 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SW
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NW
       else
               LOCAL.run=W
       endif
else
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=S
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=N
       endif
endif

if !( 0<LOCAL.run>==0 )
       for R <argv1>
               run <LOCAL.run>
       endfor
       return 1
endif

return 0


//*****************************************************************************
// HILIGHT <UID>, <COLOR>
//*****************************************************************************
//Faz <UID> parecer ter cor <color> pada o default por 3 segundos.
[FUNCTION hilight]
OBJ=<argv0>
LOCAL.y=<eval <obj.p.y>|08000>
SENDPACKET 01A W16 D<obj.uid> W<obj.dispiddec> W<obj.p.x> W<LOCAL.y> B<obj.p.z> W<argv1>
obj.timerf 3,update

//*****************************************************************************
// blindItemMsg <UID>, <COLOR>, <message>
//*****************************************************************************
//Faz <UID> mandar <message> em <color> para o default.
[function blindItemMsg]
sendpacket 01c W<hval strlen(<argv2>) + 45> D<argv0> W0FFFF B07 W<argv1> W03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <asc <ARGV2>> 00

//*****************************************************************************
// dumpChar
//*****************************************************************************
//faz um dump completo do char na console
[FUNCTION dumpChar]
serv.log *********************** DUMP CHAR *************************
serv.log UID:<uid> F:<flags> ACCT:<account> NAME:<tag.name>
serv.log ************************* EQUIP ***************************
for layer 1 24
    obj=<findlayer.<local.layer>>
    if (<obj>)
        serv.log U:<obj> A:<obj.attr> T:<obj.timer> B:<obj.baseid> L:<LOCAL.layer> N:<obj.name>
    endif
endfor
serv.log *********************** MEMORIES **************************
forcharlayer 30
    serv.log U:<uid> A:<attr> T:<timer> B:<baseid> N:<name>
endfor
serv.log ************************ EVENTS ***************************
LOCAL.c=<events>
while (!strmatch(<LOCAL.c>,0))
    serv.log <strarg <LOCAL.c>>
    LOCAL.c=<streat <LOCAL.c>>
end
serv.log ************************* TAGS ****************************
LOCAL.c=<eval <tagcount>-1>
for i 0 <LOCAL.c>
    serv.log <tagat.<local.i>>
endfor
serv.log ***************** CTAGS [CONSOLE ONLY] ********************
ctaglist log
serv.log *********************** END DUMP **************************

//*****************************************************************************
// movedir <dir>
//*****************************************************************************
//Faz <UID> andar 1 tile na direção <dir>
[FUNCTION movedir]
DOSWITCH <argn1>
 MOVE N
 MOVE NE
 MOVE E
 MOVE SE
 MOVE S
 MOVE SW
 MOVE W
 MOVE NW
ENDDO

//*****************************************************************************
// stun <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos.
[FUNCTION stun]
if (!<IsGM>)
 if (<IsStunned>)
  findid.i_stun.more2 += <argn>
  sysmessagered Sua paralizia piorou!
 else
  serv.newitem i_stun
  equip <new>
  new.more2 <argn>
  new.timer=1
 endif
endif

[FUNCTION IsStunned]
if (<src.restest 1 i_stun>)
 return 1
endif
return 0

[ITEMDEF i_stun]
//memory de paralização total
ID=i_rune_paralyze
type=t_eq_script
name=Stun
layer=layer_special

on=@equip
src.flags |= statf_freeze
src.sysmessagered Voce esta paralizado!
more1=<src>

on=@timer
//se fim do stun, ou removido por outros meios, ou morto, ou em sleep
if (!<more2>) || !(<cont.flags>&statf_freeze) || (<cont.flags>&012) //Dead ou sleep
    remove
else
    timer = 1
    more2 -= 1
endif
return 1

on=@destroy
obj=<more1>
obj.flags &= ~statf_freeze

//*****************************************************************************
// nomove <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos mas permite ações como skills, magia, luta e usar objetos.
[FUNCTION nomove]
if (!<IsGM>)
 if (<IsNomove>)
  tag.nomovetill += <eval <argn>*10>
  sysmessagered Sua imobilidade piorou!
 else
  tag.nomovetill = <eval <serv.time>+(<argn>*10)>
  sysmessagered Voce nao consegue andar!
 endif
endif

[FUNCTION IsNomove]
if (<tag0.nomovetill> > <serv.time>)
 return 1
endif
return 0

//*****************************************************************************
// f_consumeMana <mana>
//*****************************************************************************
//Tenta consumir <argn> mana. Se tiver o suficiente retorna 1.
//Se não tiver, não consome e retorna 0.
[FUNCTION f_consumeMana]
IF (<IsGM>)
 return 1
ELIF (<mana> >= <argn>)
 mana=<mana>-<argn>
 return 1
ENDIF
return 0

//*****************************************************************************
// aid
//*****************************************************************************
//Revive, revitaliza e cura um char. Usar .set aid ou .xaid em outros chars
[FUNCTION aid]
if (<restest 1 i_mry_desmaio>)
 f_returnToLife
endif
hits = <maxhits>
mana = <maxmana>
stam = <maxstam>
if (<IsPoisoned>)
 spelleffect s_cure,200.0 <UID>
endif
tag.morte_desmaios=0

//*****************************************************************************
// f_personalLight <0 a 30>
//*****************************************************************************
//Troca a luz do client por sendpack
//0 nesse caso eh escuro e 30 claro
[function f_personalLight]
if (<IsPLayer>)
    if (<IsOnline>)
       sendpacket 04E D<uid> <hval <args>>
    endif
endif

//*****************************************************************************
// ISMYENEMY <UID>
//*****************************************************************************
//Retorna se <argn1> é meu inimigo ou não
[FUNCTION ISMYENEMY]
//Função principal
ref1=<argn>
if (<f_enemyCheck <ref1.uid>>) || (<ref1.f_enemyCheck <UID>>)
 return 1
endif
return 0

[FUNCTION f_enemyCheck]
//Função coadjuvante
ref1=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<ref1.UID>) && (<COLOR>&(memory_fight|memory_iaggressor|memory_harmedby|memory_aggreived|memory_war_targ))
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// ISMYMASTER <UID>
//*****************************************************************************
//Retorna se sou pet de <argn1> ou não
[FUNCTION ISMYMASTER]
obj=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<obj.UID>) && (<COLOR>&memory_ipet)
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// f_timestring <num>
//*****************************************************************************
//retorna uma string ##d##h##m##s
[FUNCTION f_timestring]
if (<ISEMPTY <argn>>)
 return 0
endif
WHILE (<argn> >= 86400)
 argn -= 86400
 LOCAL.d += 1
END
WHILE (<argn> >= 3600)
 argn -= 3600
 LOCAL.h += 1
END
WHILE (<argn> >= 60)
 argn -= 60
 LOCAL.m += 1
END
RETURN <QVAL <LOCAL.d> ? <dLOCAL.d>d :><QVAL <LOCAL.h> ? <dLOCAL.h>h :><QVAL <LOCAL.m> ? <dLOCAL.m>min :><QVAL <argn> ? <eval <argn>>s :>


//*****************************************************************************
// correct_disp
//*****************************************************************************
//Força correão de resdisp de todas as contas.
[FUNCTION correct_disp]
FOR acc 0 <eval <serv.accounts>-1>
 if (<serv.account.<local.acc>.resdisp> =! 5) || (<ISEMPTY <serv.account.<local.acc>.resdisp>>)
  serv.account.<local.acc>.resdisp = 5
  LOCAL.c += 1
 endif
 local.i += 1
endfor
sysmessageyellow Corrigiras <dLOCAL.c> contas de <dLOCAL.i>.

//*****************************************************************************
// disturb
//*****************************************************************************
//Marca cTAG.disturb=1 de quem carrega estes events e é perturbado.
[EVENTS e_no_attack]
on=@hit
disturb

on=@GetHit
disturb

on=@SpellEffect
disturb

[EVENTS e_no_dclick]
on=@dclick
disturb

on=@itemdclick
disturb

on=@SkillStart
disturb

[FUNCTION disturb]
cTAG.disturb 1

//#######################################################
// f_RemoveList <item>,<lista>
//#######################################################
//Remove <item> de uma lista de UIDs separada por ; em <lista>
//e retorna <lista> sem <item>.
[FUNCTION f_RemoveList]
LOCAL.pat=<argv0>
LOCAL.parts=<EXPLODE ;,<argv1>>
//SAY <LOCAL.pat>
//SYSMESSAGE <LOCAL.parts>
_f_RemoveList <LOCAL.pat>,<LOCAL.parts>
timerf 1,VAR.ret,
if (STRMATCH(00,<var.ret>))
 RETURN
ENDIF
RETURN <VAR.ret>

[FUNCTION _f_RemoveList]
LOCAL.lARG=<eval <argv>-1>
FOR i 2 <LOCAL.lARG>
 LOCAL.arg=<ARGV[<LOCAL.i>]>
 IF (<ISNUM <LOCAL.arg>>)
  IF (<LOCAL.arg> != 0) && (<LOCAL.arg>!=<ARGV[0]>) && (<LOCAL.arg>)
   LOCAL.ret=<LOCAL.ret>;<LOCAL.arg>
  ENDIF
 ENDIF
ENDFOR
LOCAL.ret=<STRSUB 2 STRLEN(<LOCAL.ret>) <LOCAL.ret>>
VAR.ret=<LOCAL.ret>

//*****************************************************************************
// formatDecimal( number )
//*****************************************************************************
//o sphere se enrosca quando usa FLOAT. com float ele sempre mostra em
//decimal, e com inteiro ele mostra em hex.
//essa funcao retorna sempre decimal
[FUNCTION formatDecimal]
if (<strpos 0 . <argv0>> > 0)
    return <argv0>          //xxx.yyy
else
    return <eval <argv0>>   //xxx
endif

//*****************************************************************************
// guard (uidToGuard) XXX
//*****************************************************************************
[FUNCTION guard]
serv.newitem=i_memory
new.color=memory_guard
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Guard

//*****************************************************************************
// friend (uidFriend)
//*****************************************************************************
[FUNCTION friend]
serv.newitem=i_memory
new.color=memory_friend
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Friend

//*****************************************************************************
// transfer (uidToTransfer)
//*****************************************************************************
[FUNCTION transfer]
memoryfindtype.memory_ipet.remove
serv.newitem=i_memory
new.color=memory_ipet
new.more1=04
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.name=Pet
flags=<flags>|statf_pet

//*****************************************************************************
// setmemory (<memory_type>,<UID>)
//*****************************************************************************
[FUNCTION setmemory]
FORCHARLAYER 30
    if (<TYPE>==t_eq_memory_obj) && (<link>==<argv1>)
        color |= <argv0>
        obj=<argv1>
        IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
            name=<obj.tag.name>
        ELSE
            name=<obj.name>
        ENDIF
        return 1
    endif
ENDFOR

serv.newitem i_memory
new.color=<argv0>
new.cont=<uid>
new.timer=1200
new.link=<argv1>
obj=<argv1>
IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
    new.name=<obj.tag.name>
ELSE
    new.name=<obj.name>
ENDIF

//*****************************************************************************
// npc_follow (uidFollowed)
//*****************************************************************************
[FUNCTION npc_follow]
action=064
act=<argn>

//*****************************************************************************
// npc_move (xTo,yTo,zTo)
//*****************************************************************************
[FUNCTION npc_move]
action=066
actp=<args>

//*****************************************************************************
// npc_stop()
//*****************************************************************************
[FUNCTION npc_stop]
action=065
tag.stop=1
flags=<flags>&~statf_war

//*****************************************************************************
// npc_wander()
//*****************************************************************************
[FUNCTION npc_wander]
action=067

//*****************************************************************************
// liquidcont <LIQUID_*>
//*****************************************************************************
//Verifica o quanto de liquido LIQUID_* o default tem.
[FUNCTION liquidcont]
IF (<IsEmpty <argv[0]>>)
 return 0
endif
IF (!<IsNum <argv[0]>>)
 IF (STRMATCH(LIQUID_*,<argv[0]>))
  LOCAL.liq=<DEF.<argv[0]>>
 ELSE
  RETURN 0
 ENDIF
ELSE
 LOCAL.liq=<argv[0]>
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.ret += <more1>
 endif
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// liquidtest <amount>,<LIQUID_*>
//*****************************************************************************
//Retorna 1 se o DEFAULT tem <amount> doses de LIQUID_*. Retorna 0 se não tiver.
[FUNCTION liquidtest]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (<liquidcont <LOCAL.liq>> >= <LOCAL.qtd>)
 RETURN 1
ELSE
 RETURN 0
ENDIF

//*****************************************************************************
// consumeliquid <amount>,<LIQUID_*>
//*****************************************************************************
//Consome <amount> doses de LIQUID_* e retorna 1. Se não tiver o suficiente,
// consome tudo que tiver porem retorna 0
[FUNCTION consumeliquid]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (!<IsNum <LOCAL.liq>>)
 IF (STRMATCH(LIQUID_*,<LOCAL.liq>))
  LOCAL.liq=<DEF.<LOCAL.liq>>
 ELSE
  say esquece
  RETURN 0
 ENDIF
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.qtd -= <ConsumeRecipient <LOCAL.qtd>>
  IF (<LOCAL.qtd> <= 0)
   RETURN 1
  ENDIF
 endif
ENDFOR
RETURN 0

//*****************************************************************************
// split_key_val( string )
//*****************************************************************************
//separa uma string q esteja no formato "valor chave, valor chave" em uma tabela
//temporaria.
//o numero de linhas é encontrado em ctag.spkv_keys
//os resultados estao em ctag.spkv_rXX_k para chaves e ctag.spkv_rXX_v para valores
//XX vai de 0 a (ctag.spkv_keys - 1)
//um exemplo de uso pode ser para separar a lista de foodtype dos NPCs

//key separator: ','
//val separator: ' '
[FUNCTION split_key_val]

LOCAL.s=<args>
LOCAL.i=<strpos 0 , <LOCAL.s>>
ctag.spkv_keys=0

if (strlen(<args>)<=1)
    return
endif

while ( <LOCAL.i> > 0 && <ctag.spkv_keys=0> < 10 )
    split_key_val_ <strsub 0 <LOCAL.i> <LOCAL.s>>

    LOCAL.s=<strsub <eval <LOCAL.i>+1> 60 <LOCAL.s>>
    LOCAL.i=<strpos 0 , <LOCAL.s>>
endwhile
split_key_val_ <LOCAL.s>

[FUNCTION split_key_val_]
LOCAL.s=<strtrim <args>>
LOCAL.a=<strarg <LOCAL.s>>
LOCAL.b=<streat <LOCAL.s>>

if (strlen(<LOCAL.b>)>1)
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.b>
    ctag.spkv_r<ctag.spkv_keys>_v=<LOCAL.a>
else
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.a>
    ctag.spkv_r<ctag.spkv_keys>_v=0
endif
ctag.spkv_keys += 1

//*****************************************************************************
// UID.inContainer( containerUid )
//*****************************************************************************
//retorna 1 se UID estiver no container containerUid
[FUNCTION inContainer]
REF1=<argv0>
//ignora se chegar em um char/player
if (<uid> < 040000000)
    return 0
//ok, achou    
elif (<cont>==<ref1>)
    return 1
//nao eh mas tem mais container pra procurar
elif (<cont>)
    return <cont.inContainer <ref1>>
//acabou, nao achou
else
    return 0
endif

//*****************************************************************************
// skillchance <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
//rotina do TARAN similar a skillcheck
//retorna uma chance, de 0 a 1000 baseado no valor fornecido skillValue, o valor
//de comparação valueRequired e o valor de -3dB da curva boca de sino.
[FUNCTION skillchance]
LOCAL.db=<argv2>
if !<argv2>
    LOCAL.db=100
endif
LOCAL.skill_diff=<eval <argv1>-<argv0>>
LOCAL.skill_bell=<eval randbell( <LOCAL.skill_diff>,<LOCAL.db>)>
if <LOCAL.skill_diff> < 0
    LOCAL.skill_bell=<eval 1000 - <LOCAL.skill_bell>>
endif
return <LOCAL.skill_bell>

//*****************************************************************************
// belltest <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
[FUNCTION belltest]
if <R1000> < <skillchance <argv0>,<argv1>,<argv2>>
    return 1
else
    return 0
endif

//*****************************************************************************
// playeritem
//*****************************************************************************
//Mostra quanto de um determinado ID o player tem na bag + bank. ou num target container qualquer
[FUNCTION playeritem]
if <isempty <args>>
//    sysmessageyellow Use .playeritem ITEM_ID
    promptconsole playeritem Qual ITEM_ID?
elif <argo>
    LOCAL.pack=<argo.rescount <args>>
    LOCAL.bank=<argo.findlayer.layer_bankbox.rescount <args>>
    LOCAL.total=<eval <LOCAL.pack>+<LOCAL.bank>>
    sysmessagegreen <argo.tag.name> tem <dLOCAL.total> <args>.
else
    sysmessagered Selecione o alvo:
    targetfg playeritem <args>
endif

//****************************************************************************
//
//              Sistema de help
//
//****************************************************************************
[COMMENT HELP]
Esta seção deve ser movida daqui para um novo arquivo assim que depurada.
Sempre que o botão Help do client é acionado, a função HelpPage é chamada.
Foi criado um sistema de Help gump based com links externos para o Wiki
Para abrir o browser para um dado link usa-se o comando WEBLINK <link>

[FUNCTION HelpPage]
dialog d_help

[DIALOG d_help]
100,75
page 0
resizepic 50 31 2620 500 400
checkertrans 55 38 490 385
gumppic 0 0 10400
gumppic 0 160 10401
gumppic 0 356 10402
gumppic 518 -2 10410
gumppic 518 160 10411
gumppic 518 356 10412
gumppic 225 45 2501
dtext 231 45 26 Mystical Tales Shard
resizepic 92 87 2620 416 124
dtext 256 93 48 Estatisticas
resizepic 92 226 2620 416 91
resizepic 92 329 2620 416 84
dtext 104 112 166 Existem <serv.clients> jogadores online no momento.
dtext 104 128 166 O servidor esta rodando ha <eval <serv.timeup>/86400> dias desde o ultimo reset.
dtext 104 144 166 O mundo tem <serv.age> dias, <serv.items> itens e <serv.chars> personagens.
dtext 104 160 166 O servidor esta usando <eval <serv.mem>/1024>MB de memoria.
dtext 104 176 166 Existe um total de <serv.accounts> contas cadastradas no servidor.
dtext 277 232 48 Guias
button 104 252 2224 2223 1 0 1
dtext 128 248 166 Racas
button 104 268 2224 2223 1 0 2
dtext 128 264 166 Classes
button 104 285 2224 2223 1 0 3
dtext 128 280 166 Criacao de personagem
button 296 252 2224 2223 1 0 4
dtext 320 248 166 Skills
button 296 268 2224 2223 1 0 5
dtext 320 264 166 Sistemas diversos
dtext 320 280 166 Tabela de precos
button 296 285 2224 2223 1 0 6
dtext 264 336 48 Problemas?
button 104 356 2224 2223 1 0 7
dtext 128 352 166 Pergunte em nosso Forum
button 104 372 2224 2223 1 0 8
dtext 128 368 166 Reportar um bug/mau-funcionamento
button 104 388 2224 2223 1 0 9
dtext 128 384 166 Chame um Game Master

[DIALOG d_help text]
Mystical Tales Shard
Estatisticas
Existem <serv.clients> jogadores online no momento.
O servidor esta rodando ha <serv.age> dias desde o ultimo reset.
Existem <serv.items> itens e <serv.chars> personagens no mundo.
O servidor esta usando <serv.mem>kb de memoria.
Existe um total de <serv.accounts> contas cadastradas no servidor.
Guias
Racas
Classes
Criacao de personagem
Skills
Sistemas diversos
Tabela de precos
Problemas?
Pergunte em nosso Forum
Reportar um bug/mau-funcionamento
Chame um Game Master

[DIALOG d_help button]
ON=1
// Raças
WEBLINK www.myt.com.br/wiki/index.php?title=Ra%C3%A7as

ON=2
// Classes
WEBLINK www.myt.com.br/wiki/index.php/Classes

ON=3
// Criação de char
WEBLINK www.myt.com.br/wiki/index.php?title=Cria%C3%A7%C3%A3o_de_personagem

ON=4
// Skills
WEBLINK www.myt.com.br/wiki/index.php/Category:Skills

ON=5
// Sistemas
WEBLINK www.myt.com.br/wiki/index.php/Category:Sistemas

ON=6
// Tabela de preços
WEBLINK www.myt.com.br/wiki/index.php/Tabela_de_Pre%C3%A7os

ON=7
// Forum
WEBLINK forum.myt.com.br/

ON=8
// Bug
WEBLINK www.myt.com.br/smf/index.php?topic=825

ON=9
// Page
sysmessagered ATENCAO!!!
sysmessageyellow Descreva seu problema com precisao. Seja direto e nao brinque com este sistema sob pena de prisao!
GMPAGE Other

[EOF]
