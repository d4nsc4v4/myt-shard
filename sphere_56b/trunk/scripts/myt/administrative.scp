[DEFNAME administrative_constants]
SM_RED=028
SM_GREEN=044
SM_BLUE=04
SM_YELLOW=036
SM_ORANGE=02c
SND_GLASS={{03e 041} 1 {038d 0390} 1}
SND_THUNDER={05CE 1 028 1 029 1 0206 1}

spellflag_eval_boosts 0400000		//Spellflag. Eval int é 50% do EFFECT

[PLEVEL 6]
f_connectDB
worldrespawn

//*****************************************************************************
//*****************************************************************************
// FUNCOES
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
// f_oncommand( )
//*****************************************************************************
[FUNCTION f_oncommand]
if strmatch("<args>","xresurrect")
    src.sysmessagered Utilize xress
    return 1
elif (strmatch(hungry,<args>))
    comida
    return 1
elif (strmatch(cast*,<args>))
    if (!<src.IsGM>)
     src.sysmessagered Comando bloquado! Risco de Exploit. Sua conta foi marcada.
     src.targ.tag0.fconf=<src.targ.tag0.fconf>+1
     serv.allclients broadstaff Exploit! Tentou usar comando .cast,"<src.account>"
     serv.log [Magia] EXPLOIT:: <src.tag.name> [<src.account] tentou usar comando .cast
     event_note <src.uid>,Exploit! Tentou usar comando .cast
     return 1
    endif
endif

//*****************************************************************************
// f_connectDB( )
//*****************************************************************************
[FUNCTION f_connectDB]
DB.CONNECT
if (<DB.CONNECTED>)
    SERV.log MySQL debug: MySQL successfully connected!
else
    SERV.log MySQL debug: MySQL not connected!
endif


//*****************************************************************************
// f_sendMessage( uidPlayer, message, msgColor )
//*****************************************************************************
//envia mensagem para um player online. se estiver offline a mensagem é armazenada no banco
//e entregue no proximo login.
//
// ARGV[0] --> UID destino
// ARGV[1] --> mensagem
// ARGV[2] --> cor (SM_RED,SM_GREEN...etc)
[FUNCTION f_sendMessage]
    
//save OBJ ref.
    LOCAL.obj=<OBJ>
    
    OBJ=<argv[0]>
    if ( <OBJ.isonline> )
        OBJ.sysmessage @<argv[2]> <argv[1]>
    else
        if ( <DB.connected> )
            DB.EXECUTE "INSERT INTO messageBox SET timestamp=NOW(), message='<argv[1]>', status='Pending', triggerUid=<eval <SRC.uid>>, toUid=<eval <argv[0]>>, color=<eval <argv[2]>>"
        endif
    endif
    
    OBJ=<LOCAL.obj>
    
//*****************************************************************************
// f_deliverPendingMessages( )
//*****************************************************************************
//chame essa funcao no login para enviar as mensagens pendentes ao player.  
//SRC é o player fazendo login
[FUNCTION f_deliverPendingMessages]
if ( <DB.connected> )
    DB.QUERY "SELECT message,color FROM messageBox WHERE status='Pending' AND toUid=<eval <SRC.uid>>"
    if (<DB.ROW.NUMROWS> > 0)
        for R 0 <eval <DB.ROW.NUMROWS>-1>
            SRC.sysmessage @<DB.ROW.<eval <LOCAL.R>>.color> <DB.ROW.<eval <LOCAL.R>>.message>
        end
        DB.EXECUTE "UPDATE messageBox SET status='Sent' WHERE toUid=<eval <SRC.uid>>"
    endif
endif
    

//*****************************************************************************
// f_isWeapon( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeapon]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_axe )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_sharp )
        return 1
    elif ( <LOCAL.type>==t_weapon_sword )
        return 1
    elif ( <LOCAL.type>==t_weapon_fence )
        return 1
    elif ( <LOCAL.type>==t_weapon_bow )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <LOCAL.type>==t_weapon_arrow )
        return 1
    elif ( <LOCAL.type>==t_weapon_bolt )
        return 1
    elif ( <LOCAL.type>==t_weapon_xbow )
        return 1
    elif ( <LOCAL.type>==t_string )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isWeaponTool( item )
//*****************************************************************************
//retorna 1 se o argumento for uma arma
[FUNCTION f_isWeaponTool]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_weapon_mace_smith )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_staff )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_crook )
        return 1
    elif ( <LOCAL.type>==t_weapon_mace_pick )
        return 1
    elif ( <uid.<argn>.id>==0F51 ) || ( <uid.<argn>.id>==0EC4 ) || ( <uid.<argn>.id>==013F6 ) || ( <uid.<argn>.id>==0EC2 )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isArmor( item )
//*****************************************************************************
//retorna 1 se o argumento for uma armadura (ou escudo)
[FUNCTION f_isArmor]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_armor )
        return 1
    elif ( <LOCAL.type>==t_armor_leather )
        return 1
    elif ( <LOCAL.type>==t_shield )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRegsOrMagic( item )
//*****************************************************************************
//retorna 1 se o argumento for uma reagente ou magico
[FUNCTION f_isRegsOrMagic]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_wand )
        return 1
    elif ( <LOCAL.type>==t_potion )
        return 1
    elif ( <LOCAL.type>==t_potion_empty )
        return 1
    elif ( <LOCAL.type>==t_reagente )
        return 1
    elif ( <LOCAL.type>==t_almofariz )
        return 1
    elif ( <LOCAL.type>==t_espiriteira )
        return 1
    elif ( <LOCAL.type>==t_destilador )
        return 1
    elif ( <LOCAL.type>==t_balao )
        return 1
    elif ( <LOCAL.type>==t_misturador )
        return 1
    elif ( <LOCAL.type>==t_tubo )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isFood( item )
//*****************************************************************************
//retorna 1 se o argumento for um alimento/comestivel
[FUNCTION f_isFood]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_food )
        return 1
    elif ( <LOCAL.type>==t_food_raw )
        return 1
    elif ( <LOCAL.type>==t_fish )
        return 1
    elif ( <LOCAL.type>==t_fruit )
        return 1
    elif ( <LOCAL.type>==t_meat_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isMisc( item )
//*****************************************************************************
//retorna 1 se o argumento for ferramenta, movel, etc
[FUNCTION f_isMisc]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clock )
        return 1
    elif ( <LOCAL.type>==t_termometro )
        return 1
    elif ( <LOCAL.type>==t_musical )
        return 1
    elif ( <LOCAL.type>==t_ar_projeto )
        return 1
    elif ( <LOCAL.type>==t_ar_livro )
        return 1
    elif ( <LOCAL.type>==t_carpentry )
        return 1
    elif ( <LOCAL.type>==t_chair )
        return 1
    elif ( <LOCAL.type>==t_sextant )
        return 1
    elif ( <LOCAL.type>==t_table )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_shaft )
        return 1
    elif ( <LOCAL.type>==t_tinker_tools )
        return 1
    elif ( <LOCAL.type>==t_carpentry_tool )
        return 1
    elif ( <LOCAL.type>==t_cooking_tool )
        return 1
    elif ( <LOCAL.type>==t_bancada )
        return 1
    elif ( <LOCAL.type>==t_light_out )
        return 1
    elif ( <LOCAL.type>==t_fish_pole )
        return 1
    elif ( <LOCAL.type>==t_oleo )
        return 1
    elif ( <LOCAL.type>==t_book )
        return 1
    elif ( <LOCAL.type>==t_sand )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_buy_misc )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_luz_oleo )
        return 1        
    elif ( <LOCAL.type>==t_container )
        return 1   
    elif ( <LOCAL.type>==t_fechadura )
        return 1 
    else
        return 0
    endif

//*****************************************************************************
// f_isWearable( item )
//*****************************************************************************
//retorna 1 se o argumento for roupas, joias, etc
[FUNCTION f_isWearable]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_clothing )
        return 1
    elif ( <LOCAL.type>==t_cloth )
        return 1
    elif ( <LOCAL.type>==t_tailoring )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_jewelry )
        return 1
    elif ( <LOCAL.type>==t_bandagem )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// f_isRaw( item )
//*****************************************************************************
//retorna 1 se o argumento for materia prima
[FUNCTION f_isRaw]
    LOCAL.type = <uid.<argn>.type>
    if ( <LOCAL.type>==t_log )
        return 1
    elif ( <LOCAL.type>==t_ore )
        return 1
    elif ( <LOCAL.type>==t_ingot )
        return 1
    elif ( <LOCAL.type>==t_seed )
        return 1
    elif ( <LOCAL.type>==t_leather )
        return 1
    elif ( <LOCAL.type>==t_loom )
        return 1
    elif ( <LOCAL.type>==t_feather )
        return 1
    elif ( <LOCAL.type>==t_wool )
        return 1
    elif ( <LOCAL.type>==t_fur )
        return 1
    elif ( <LOCAL.type>==t_thread )
        return 1
    elif ( <LOCAL.type>==t_yarn )
        return 1
    elif ( <LOCAL.type>==t_cotton )
        return 1
    elif ( <LOCAL.type>==t_preitem_bowcraft )
        return 1
    elif ( <LOCAL.type>==t_preitem_carpentry )
        return 1
    elif ( <LOCAL.type>==t_arame )
        return 1
    elif ( <LOCAL.type>==t_buy_raw )
        return 1
    elif ( <LOCAL.type>==t_recipient )
        return 1
    elif ( <LOCAL.type>==t_hide )
        return 1
    elif ( <LOCAL.type>==t_grain )
        return 1
    else
        return 0
    endif

//*****************************************************************************
// isLight
//*****************************************************************************
//retorna 1 se DEFAULT for luz (e aceso)
[FUNCTION isLight]
if <type>==t_light_lit
    return 1
elif (<type>==t_luz_oleo) && (<timer>>0)
    return 1
endif
return 0
    
//*****************************************************************************
// wipeObject <DEFNAME> Remove todos os itens <DEFNAME> do world.
//*****************************************************************************
[FUNCTION wipeObject]
IF !(<ARGN>)
 IF (<ISEMPTY <DEF.<ARGS>>>)
  SYSMESSAGE <args> nao existe.
  RETURN 0
 endif
endif
IF !(<ISEMPTY <ARGS>>)
 IF !(<SERV.ITEMDEF.<ARGS>>) && !(<SERV.CHARDEF.<ARGS>>)
  SYSMESSAGE <ARGS> nao eh um item nem criatura.
  RETURN 0
 endif
 FORINSTANCES <argv[0]>
  LOCAL.wipe=<local.wipe>+1
  remove
 ENDFOR
 if (<IsGM>)
  sysmessageorange Removidos <eval <LOCAL.wipe>> instancias de <SERV.RESOURCES.<argv[0]>.NAME>
 endif
endif

//*****************************************************************************
//  CRY Faz o char gritar de dor e animar (compatibilidade com 55i)
//*****************************************************************************

[FUNCTION cry]
//// anima
anim 20                     //Animação de @GetHit
bark 3

//*****************************************************************************
//  EFFECTSPELL <spell>,<skill_dif>,<UIDcaster>
//*****************************************************************************
//Retorna o EFFECT de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION EFFECTSPELL]
LOCAL.skill=<argn1>
LOCAL.min=<minimum <SERV.SPELL.<argv0>.EFFECT>>
LOCAL.eff=<maximum <SERV.SPELL.<argv0>.EFFECT>>

//Eavl Int entra na jogada?
if (<serv.resources.<argv0>.FLAGS>&spellflag_eval_boosts)
 if (0<argv2>)
  obj=<argv2>
  local.skill=<eval (<local.skill>/2)+(<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<obj.EvaluatingIntel>>/2)>
  obj.SKILL_GAIN Skill_EvaluatingIntel
 endif
endif

//Resisting spells?
if !<isitem>
 if (<serv.resources.<argv0>.FLAGS>&spellflag_resist)
  if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
   sysmessageblue Voce resiste a magia.
   //Resistir totalmente?
   if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
    LOCAL.min=0
    LOCAL.eff=0
    sfx 05C1
    emotered resistiu
   else                      //Resistir parcialmente
    LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
   endif
  endif
  SKILL_GAIN Skill_MagicResistance
 endif
endif

local.err=<eval 100-<R0,<f_rangeValue 0,20,<argv1>>>>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
local.eff=<eval (<local.eff>*<local.err>)/100>
RETURN <eval <LOCAL.eff>>


//*****************************************************************************
//  DURATIONSPELL <spell>,<skill_dif>,<UIDcaster>
//*****************************************************************************
//Retorna o DURATION de uma magia de acordo com uma skill
//Se a spell tiver spellflag_resist, calcula o retorno para MagicResist do DEFAULT.
[FUNCTION DURATIONSPELL]
LOCAL.skill=<argn1>
LOCAL.min=<minimum <SERV.SPELL.<argv0>.DURATION>>
LOCAL.eff=<maximum <SERV.SPELL.<argv0>.DURATION>>

//Eavl Int entra na jogada?
if (<serv.resources.<argv0>.FLAGS>&spellflag_eval_boosts)
 if (0<argv2>)
  obj=<argv2>
  local.skill=<eval (<local.skill>/2)+(<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<obj.EvaluatingIntel>>/2)>
  obj.SKILL_GAIN Skill_EvaluatingIntel
 endif
endif

//Resisting spells?
if !<isitem>
 if (<serv.resources.<argv0>.FLAGS>&spellflag_resist)
  if (<BELLTEST <MagicResistance>,<LOCAL.skill>>)
   //Resistir totalmente?
   sysmessageblue Voce resiste a magia.
   if (<BELLTEST <MagicResistance>,140.0>)   //Resistir totalmente
    LOCAL.min=0
    LOCAL.eff=0
    sfx 05C1
    emotered resistiu
   else                      //Resistir parcialmente
    LOCAL.eff=<f_rangeValue <LOCAL.min>,<LOCAL.eff>,<eval 1010-<MagicResistance>>>
   endif
  endif
  SKILL_GAIN Skill_MagicResistance
 endif
endif

local.err=<eval 100-<R0,<f_rangeValue 0,20,<argv1>>>>
LOCAL.eff=<f_rangeValue <LOCAL.min>, <LOCAL.eff>, <argv1>>
local.eff=<eval (<local.eff>*<local.err>)/100>

RETURN <eval <LOCAL.eff>>

//*****************************************************************************
//  DAMAGESPELL <spell>,<dam_type>,<skill>,<UIDcaster>
//*****************************************************************************
//Danifica conforme a magia <argv0> com tipo <argv1> como se tivesse magery <argv2> por <<argv3>.UID>
[FUNCTION damagespell]
LOCAL.dam=<EFFECTSPELL <argv0>, <argv2>, <argv3>>
DAMAGE <LOCAL.dam> <EVAL <argv1>> <argv3>                           //aplica o dano com o tipo modificado
RETURN <LOCAL.dam>

//*****************************************************************************
//  IsStonned
//*****************************************************************************
//Retorna se o char está stonnado ou não.
[FUNCTION IsStonned]
if (<restest 1 i_stonned>)
 RETURN 1
else
 RETURN 0
endif

//*****************************************************************************
//  Stonned <tempo>
//*****************************************************************************
//Petrifica um char por <tempo> segundos.
[FUNCTION Stonned]
if (<IsStonned>)
 RETURN 0
endif
serv.newitem i_stonned
new.timer=<argn>
equip <new.uid>
RETURN 1

[ITEMDEF i_stonned]
ID=020A5
NAME=Petrificado
TYPE=t_eq_script
LAYER=layer_special

on=@equip
cont.flags=<cont.flags>|040000
cont.update

on=@timer
cont.flags=<cont.flags>&~040000
cont.sysmessageblue Voce nao esta mais petrificado.
cont.update
remove
RETURN 1

//*****************************************************************************
// emotes
//*****************************************************************************
[FUNCTION emotegreen]
SAY @<DEF.SM_GREEN>,  *<args>*

[FUNCTION emotered]
SAY @<DEF.SM_RED>,  *<args>*

[FUNCTION emoteyellow]
SAY @<DEF.SM_YELLOW>,  *<args>*

[FUNCTION emoteblue]
SAY @<DEF.SM_BLUE>,  *<args>*

[FUNCTION emoteorange]
SAY @<DEF.SM_ORANGE>,  *<args>*

//*****************************************************************************
// sysmessage
//*****************************************************************************
[FUNCTION sysmessagered]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_RED>,3  <args>
endif

[FUNCTION sysmessageblue]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_BLUE>,3  <args> 
endif

[FUNCTION sysmessagegreen]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_GREEN>,3  <args> 
endif

[FUNCTION sysmessageyellow]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_YELLOW>,3  <args> 
endif

[FUNCTION sysmessageorange]
if (<isplayer>)
    SYSMESSAGE @<DEF.SM_ORANGE>,3  <args> 
endif

//*****************************************************************************
// Regen time
//*****************************************************************************

[FUNCTION HitsRegen]
//If <argn> is present, changes the time (in seconds) to earn a Hitpoint by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Hitpoint by regeneration.
IF (!<argn>)
 return <eval (<serv.regen0>/10)-<TAG0.OVERRIDE.Regen_0>>
endif
local.old=<eval (<serv.regen0>/10)-<TAG0.OVERRIDE.Regen_0>>
TAG.OVERRIDE.Regen_0=<eval (<serv.regen0>/10)-<argn>>
return <local.old>

[FUNCTION ManaRegen]
//If <argn> is present, changes the time (in seconds) to earn a Mana point by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Mana point by regeneration.
IF (!<argn>)
 return <eval (<serv.regen1>/10)-<TAG0.OVERRIDE.Regen_1>>
endif
local.old=<eval (<serv.regen1>/10)-<TAG0.OVERRIDE.Regen_1>>
TAG.OVERRIDE.Regen_1=<eval (<serv.regen1>/10)-<argn>>
return <local.old>

[FUNCTION StamRegen]
//If <argn> is present, changes the time (in seconds) to earn a Stam point by regeneration and returns the old value.
//If not present return the time (in seconds) to earn a Stam point by regeneration.
IF (!<argn>)
 return <eval (<serv.regen2>/10)-<TAG0.OVERRIDE.Regen_2>>
endif
local.old=<eval (<serv.regen2>/10)-<TAG0.OVERRIDE.Regen_2>>
TAG.OVERRIDE.Regen_2=<eval (<serv.regen2>/10)-<argn>>
return <local.old>


//*****************************************************************************
// decrement [amount]
//*****************************************************************************
[FUNCTION decrement]
if <argn>
    amount -= <argn>
else    
    amount -= 1
endif

if <amount> < 1
    remove
endif
update

//*****************************************************************************
// f_sendTooltip(title,text)
//*****************************************************************************
[FUNCTION f_sendTooltip]
src.addcliloc 1042971,<argv0>
src.addcliloc 1070722,<argv1>

//*****************************************************************************
// f_sendTooltipData(text)
//*****************************************************************************
[FUNCTION f_sendTooltipData]
src.addcliloc 1070722,<argv0>

//*****************************************************************************
// checkVersion([major],[lower],[minor])
//*****************************************************************************
[FUNCTION checkVersion]
if (!0<argv0>)
    return <f_checkVersion <STREAT <explode .,<CLIENTVERSION>>>>
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_checkVersion(major,lower,minor)
//*****************************************************************************
[FUNCTION f_checkVersion]
if (!0<argv0>)
    serv.log Clientversion invalido: <CLIENTVERSION> -- <argv0>::<argv1>::<argv2>
    return 0
endif
if (<argv0> > 5) || ( (<argv0>==5) && (<argv2> >= 8) )
    return 1
endif
return 0

//*****************************************************************************
// f_spreadValue(value,error)
//*****************************************************************************
//dado um valor value, retorn um valor aleatorio V+-K, onde K vai de 0 a
//(V/2) (erro 100%)
//'error' deve ser passado entre 0 (retorna 'value') e Cm (atualmente 50)

//Formula e simplificavao:
//Vn=V*[1+(2*Er-Em)/(2*Cm)]
//Vn=V*[(2*Cm)+(2*Er)-Em)]/(2*Cm)
//Vn=V*[K-Em+(2*Er)]/k
//Vn - valor falso
//V  - valor real ('value')
//Cm - Maximo % de erro (0 a 100). Atualmente ajustado em 50.
//Em - Erro máximo ('error')
//Er - Erro random (0 a Em)
[FUNCTION f_spreadValue]
return <eval (<argv0>*((100-<argv1>)+(2*<R0,<argv1>>)))/100>

//*****************************************************************************
// f_rangeValue(min,max,skill)
//*****************************************************************************
//dado um valor value, retorn um valor de acordo com uma regra de tres
//composta entre <min> e <max> de acordo com <skill>
[FUNCTION f_RangeValue]
LOCAL.min=<argv0>
LOCAL.max=<argv1>
LOCAL.skill=<argv2>
LOCAL.max=<LOCAL.max>-<LOCAL.min>
LOCAL.max=((<LOCAL.max>*<LOCAL.skill>)/1000)+<LOCAL.min>
return <eval <LOCAL.max>>

//*****************************************************************************
// f_isDisturbed()
//*****************************************************************************
//verifica se ha algum flag de perturbacao:
//statf_hallucinating|statf_fly|statf_stone|statf_polymorph|statf_war|statf_sleeping|statf_freeze|statf_dead
[FUNCTION f_isDisturbed]
if (<flags>&000540436)
    return 1
endif
return 0

//*****************************************************************************
// f_gmLog( text )
//*****************************************************************************
//exibe sysmensage para gms dentro da area da tela SOMENTE se var.gmlog estiver 
//ativo
[FUNCTION f_gmLog]
if (!<var0.gmlog>)
    return
endif
FORCLIENTS
    if (<gm>)
        sysmessageyellow <args>
    endif
ENDFOR


//*****************************************************************************
// f_npcRunStepToUid( [uid_to_go], steps,[px,py]  )
//*****************************************************************************
//npc corre em dire  o ao UID
//default: NPC que ira correr
//uid_to_go: uid alvo
//steps numero de 'run's que ira dar em direcao ao alvo
[FUNCTION f_npcRunStepToUid]
REF1=<argv0>
if (<REF1>)
    LOCAL.dx = <eval <REF1.p.x>-<p.x>>
    LOCAL.dy = <eval <REF1.p.y>-<p.y>>
else
    LOCAL.dx = <eval <argv2>-<p.x>>
    LOCAL.dy = <eval <argv3>-<p.y>>
endif

LOCAL.run=0
if ( <LOCAL.dx> > 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SE
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NE
       else
               LOCAL.run=E
       endif
elif ( <LOCAL.dx> < 0 )
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=SW
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=NW
       else
               LOCAL.run=W
       endif
else
       if ( <LOCAL.dy> > 0 )
               LOCAL.run=S
       elif ( <LOCAL.dy> < 0 )
               LOCAL.run=N
       endif
endif

if !( 0<LOCAL.run>==0 )
       for R <argv1>
               run <LOCAL.run>
       endfor
       return 1
endif

return 0


//*****************************************************************************
// HILIGHT <UID>, <COLOR>
//*****************************************************************************
//Faz <UID> parecer ter cor <color> pada o default por 3 segundos.
[FUNCTION hilight]
OBJ=<argv0>
LOCAL.y=<eval <obj.p.y>|08000>
SENDPACKET 01A W16 D<obj.uid> W<obj.dispiddec> W<obj.p.x> W<LOCAL.y> B<obj.p.z> W<argv1>
obj.timerf 3,update

//*****************************************************************************
// blindItemMsg <UID>, <COLOR>, <message>
//*****************************************************************************
//Faz <UID> mandar <message> em <color> para o default.
[function blindItemMsg]
sendpacket 01c W<hval strlen(<argv2>) + 45> D<argv0> W0FFFF B07 W<argv1> W03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <asc <ARGV2>> 00

//*****************************************************************************
// dumpChar
//*****************************************************************************
//faz um dump completo do char na console
[FUNCTION dumpChar]
serv.log *********************** DUMP CHAR *************************
serv.log UID:<uid> F:<flags> ACCT:<account> NAME:<tag.name>
serv.log ************************* EQUIP ***************************
for layer 1 24
    obj=<findlayer.<local.layer>>
    if (<obj>)
        serv.log U:<obj> A:<obj.attr> T:<obj.timer> B:<obj.baseid> L:<LOCAL.layer> N:<obj.name>
    endif
endfor
serv.log *********************** MEMORIES **************************
forcharlayer 30
    serv.log U:<uid> A:<attr> T:<timer> B:<baseid> N:<name>
endfor
serv.log ************************ EVENTS ***************************
LOCAL.c=<events>
while (!strmatch(<LOCAL.c>,0))
    serv.log <strarg <LOCAL.c>>
    LOCAL.c=<streat <LOCAL.c>>
end
serv.log ************************* TAGS ****************************
LOCAL.c=<eval <tagcount>-1>
for i 0 <LOCAL.c>
    serv.log <tagat.<local.i>>
endfor
serv.log ***************** CTAGS [CONSOLE ONLY] ********************
ctaglist log
serv.log *********************** END DUMP **************************

//*****************************************************************************
// movedir <dir>
//*****************************************************************************
//Faz <UID> andar 1 tile na direção <dir>
[FUNCTION movedir]
DOSWITCH <argn1>
 MOVE N
 MOVE NE
 MOVE E
 MOVE SE
 MOVE S
 MOVE SW
 MOVE W
 MOVE NW
ENDDO

//*****************************************************************************
// stun <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos.
[FUNCTION stun]
if (!<IsGM>)
 if (<IsStunned>)
  findid.i_stun.more2 += <argn>
  sysmessagered Sua paralizia piorou!
 else
  serv.newitem i_stun
  equip <new>
  new.more2 <argn>
  new.timer=1
 endif
endif

[FUNCTION IsStunned]
if (<restest 1 i_stun>)
 return 1
endif
return 0

[ITEMDEF i_stun]
//memory de paralização total
ID=i_rune_paralyze
type=t_eq_script
name=Stun
layer=layer_special

on=@equip
src.flags |= statf_freeze
src.sysmessagered Voce esta paralizado!
more1=<src>

on=@timer
//se fim do stun, ou removido por outros meios, ou morto, ou em sleep
if (!<more2>) || !(<cont.flags>&statf_freeze) || (<cont.flags>&012) //Dead ou sleep
    remove
else
    timer = 1
    more2 -= 1
endif
return 1

on=@destroy
obj=<more1>
obj.flags &= ~statf_freeze

//*****************************************************************************
// nomove <tempo>
//*****************************************************************************
//Paraliza o char por <tempo> segundos mas permite ações como skills, magia, luta e usar objetos.
[FUNCTION nomove]
if (!<IsGM>)
 if (<IsNomove>)
  tag.nomovetill += <eval <argn>*10>
  sysmessagered Sua imobilidade piorou!
 else
  tag.nomovetill = <eval <serv.time>+(<argn>*10)>
  sysmessagered Voce nao consegue andar!
 endif
endif

[FUNCTION IsNomove]
if (<tag0.nomovetill> > <serv.time>)
 return 1
endif
return 0

//*****************************************************************************
// f_consumeMana <mana>
//*****************************************************************************
//Tenta consumir <argn> mana. Se tiver o suficiente retorna 1.
//Se não tiver, não consome e retorna 0.
[FUNCTION f_consumeMana]
IF (<IsGM>)
 return 1
ELIF (<mana> >= <argn>)
 mana=<mana>-<argn>
 return 1
ENDIF
return 0

//*****************************************************************************
// aid
//*****************************************************************************
//Revive, revitaliza e cura um char. Usar .set aid ou .xaid em outros chars
[FUNCTION aid]
if (<restest 1 i_mry_desmaio>)
 f_returnToLife
endif
hits = <maxhits>
mana = <maxmana>
stam = <maxstam>
if (<IsPoisoned>)
 spelleffect s_cure,200.0 <UID>
endif
tag.morte_desmaios=0

//*****************************************************************************
// f_personalLight <0 a 30>
//*****************************************************************************
//Troca a luz do client por sendpack
//0 nesse caso eh escuro e 30 claro
[function f_personalLight]
if (<IsPLayer>)
    if (<IsOnline>)
       sendpacket 04E D<uid> <hval <args>>
    endif
endif

//*****************************************************************************
// ISMYENEMY <UID>
//*****************************************************************************
//Retorna se <argn1> é meu inimigo ou não
[FUNCTION ISMYENEMY]
//Função principal
ref1=<argn>
if (<f_enemyCheck <ref1.uid>>) || (<ref1.f_enemyCheck <UID>>)
 return 1
endif
return 0

[FUNCTION f_enemyCheck]
//Função coadjuvante
ref1=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<ref1.UID>) && (<COLOR>&(memory_fight|memory_iaggressor|memory_harmedby|memory_aggreived|memory_war_targ))
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// ISMYMASTER <UID>
//*****************************************************************************
//Retorna se sou pet de <argn1> ou não
[FUNCTION ISMYMASTER]
obj=<argn1>
FORCHARLAYER 30
 IF (<LINK>==<obj.UID>) && (<COLOR>&memory_ipet)
  LOCAL.ret=1
 ENDIF
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// f_timestring <num>
//*****************************************************************************
//retorna uma string ##d##h##m##s
[FUNCTION f_timestring]
if (<ISEMPTY <argn>>)
 return 0
endif
WHILE (<argn> >= 86400)
 argn -= 86400
 LOCAL.d += 1
END
WHILE (<argn> >= 3600)
 argn -= 3600
 LOCAL.h += 1
END
WHILE (<argn> >= 60)
 argn -= 60
 LOCAL.m += 1
END
RETURN <QVAL <LOCAL.d> ? <dLOCAL.d>d :><QVAL <LOCAL.h> ? <dLOCAL.h>h :><QVAL <LOCAL.m> ? <dLOCAL.m>min :><QVAL <argn> ? <eval <argn>>s :>


//*****************************************************************************
// correct_disp
//*****************************************************************************
//Força correão de resdisp de todas as contas.
[FUNCTION correct_disp]
FOR acc 0 <eval <serv.accounts>-1>
 if (<serv.account.<local.acc>.resdisp> =! 5) || (<ISEMPTY <serv.account.<local.acc>.resdisp>>)
  serv.account.<local.acc>.resdisp = 5
  LOCAL.c += 1
 endif
 local.i += 1
endfor
sysmessageyellow Corrigiras <dLOCAL.c> contas de <dLOCAL.i>.

//*****************************************************************************
// disturb
//*****************************************************************************
//Marca cTAG.disturb=1 de quem carrega estes events e é perturbado.
[EVENTS e_no_attack]
on=@hit
disturb

//on=@GetHit foi adicionado no sistema de combate o efeito de disturb
//disturb

on=@SpellEffect
disturb

[EVENTS e_no_dclick]
on=@itemdclick
disturb

on=@SkillStart
disturb

[FUNCTION disturb]
if !<NPC>
    cTAG.disturb 1
endif
//#######################################################
// f_RemoveList <item>,<lista>
//#######################################################
//Remove <item> de uma lista de UIDs separada por ; em <lista>
//e retorna <lista> sem <item>.
[FUNCTION f_RemoveList]
LOCAL.pat=<argv0>
LOCAL.parts=<EXPLODE ;,<argv1>>
//SAY <LOCAL.pat>
//SYSMESSAGE <LOCAL.parts>
_f_RemoveList <LOCAL.pat>,<LOCAL.parts>
timerf 1,VAR.ret,
if (STRMATCH(00,<var.ret>))
 RETURN
ENDIF
RETURN <VAR.ret>

[FUNCTION _f_RemoveList]
LOCAL.lARG=<eval <argv>-1>
FOR i 2 <LOCAL.lARG>
 LOCAL.arg=<ARGV[<LOCAL.i>]>
 IF (<ISNUM <LOCAL.arg>>)
  IF (<LOCAL.arg> != 0) && (<LOCAL.arg>!=<ARGV[0]>) && (<LOCAL.arg>)
   LOCAL.ret=<LOCAL.ret>;<LOCAL.arg>
  ENDIF
 ENDIF
ENDFOR
LOCAL.ret=<STRSUB 2 STRLEN(<LOCAL.ret>) <LOCAL.ret>>
VAR.ret=<LOCAL.ret>

//*****************************************************************************
// formatDecimal( number )
//*****************************************************************************
//o sphere se enrosca quando usa FLOAT. com float ele sempre mostra em
//decimal, e com inteiro ele mostra em hex.
//essa funcao retorna sempre decimal
[FUNCTION formatDecimal]
if (<strpos 0 . <argv0>> > 0)
    return <argv0>          //xxx.yyy
else
    return <eval <argv0>>   //xxx
endif

//*****************************************************************************
// maximum a,b,c...n
//*****************************************************************************
//Retorna o maior valor dos argumentos.
//xxxxx=<maximum 5,7,12,-1,120.0,750,0>
[FUNCTION maximum]
local.ret=<argv[0]>
for i 1 <eval <argv>-1>
 if (<argv[<local.i>]> > <local.ret>)
  local.ret=<argv[<local.i>]>
 endif
end
return <local.ret>

//*****************************************************************************
// minimum a,b,c...n
//*****************************************************************************
//Retorna o menor valor dos argumentos.
//xxxxx=<minimum 5,7,12,-1,120.0,750,0>
[FUNCTION minimum]
local.ret=<argv[0]>
for i 1 <eval <argv>-1>
 if (<argv[<local.i>]> < <local.ret>)
  local.ret=<argv[<local.i>]>
 endif
end
return <local.ret>

//*****************************************************************************
// minimumN a,b,c...n
//*****************************************************************************
//Retorna o menor valor dos argumentos como número natural.
//Ou seja, se o valor for < 0, ele retorna 0.
//xxxxx=<minimum 5,7,12,-1,120.0,750>
[FUNCTION minimumn]
local.ret=<minimum <args>>
IF (<local.ret> < 0)
 return 0
ENDIF
return <local.ret>

//*****************************************************************************
// mean a,b,c...n
//*****************************************************************************
//Retorna a media dos argumentos.
//xxxxx=<mean 5,7,12,-1,120.0,750,0>
[FUNCTION mean]
local.ret=0
for i 0 <eval <argv>-1>
 local.ret += <argv[<local.i>]>
end
return <eval <local.ret>/<argv>>

//*****************************************************************************
// guard (uidToGuard) XXX
//*****************************************************************************
[FUNCTION guard]
serv.newitem=i_memory
new.color=memory_guard
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Guard

//*****************************************************************************
// friend (uidFriend)
//*****************************************************************************
[FUNCTION friend]
serv.newitem=i_memory
new.color=memory_friend
new.more1=0
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.timer=60*60*4
new.name=Friend

//*****************************************************************************
// transfer (uidToTransfer)
//*****************************************************************************
[FUNCTION transfer]
memoryfindtype.memory_ipet.remove
serv.newitem=i_memory
new.color=memory_ipet
new.more1=04
new.more2=<serv.time>
new.morep=<p>
new.link=<argv0>
new.cont=<uid>
new.name=Pet
flags=<flags>|statf_pet

//*****************************************************************************
// setmemory (<memory_type>,<UID>)
//*****************************************************************************
[FUNCTION setmemory]
FORCHARLAYER 30
    if (<TYPE>==t_eq_memory_obj) && (<link>==<argv1>)
        color |= <argv0>
        obj=<argv1>
        IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
            name=<obj.tag.name>
        ELSE
            name=<obj.name>
        ENDIF
        return 1
    endif
ENDFOR

serv.newitem i_memory
new.color=<argv0>
new.cont=<uid>
new.timer=1200
new.link=<argv1>
obj=<argv1>
IF (<obj.isplayer>) && (!<IsEmpty <obj.tag.name>>)
    new.name=<obj.tag.name>
ELSE
    new.name=<obj.name>
ENDIF

//*****************************************************************************
// npc_follow (uidFollowed)
//*****************************************************************************
[FUNCTION npc_follow]
action=064
act=<argn>

//*****************************************************************************
// npc_move (xTo,yTo,zTo)
//*****************************************************************************
[FUNCTION npc_move]
action=066
actp=<args>

//*****************************************************************************
// npc_stop()
//*****************************************************************************
[FUNCTION npc_stop]
action=065
tag.stop=1
flags=<flags>&~statf_war

//*****************************************************************************
// npc_wander()
//*****************************************************************************
[FUNCTION npc_wander]
action=067

//*****************************************************************************
// npc_release()
//*****************************************************************************
[FUNCTION npc_release]
memoryfindtype.memory_ipet.remove

//*****************************************************************************
// liquidcont <LIQUID_*>
//*****************************************************************************
//Verifica o quanto de liquido LIQUID_* o default tem.
[FUNCTION liquidcont]
IF (<IsEmpty <argv[0]>>)
 return 0
endif
IF (!<IsNum <argv[0]>>)
 IF (STRMATCH(LIQUID_*,<argv[0]>))
  LOCAL.liq=<DEF.<argv[0]>>
 ELSE
  RETURN 0
 ENDIF
ELSE
 LOCAL.liq=<argv[0]>
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.ret += <more1>
 endif
ENDFOR
RETURN <LOCAL.ret>

//*****************************************************************************
// liquidtest <amount>,<LIQUID_*>
//*****************************************************************************
//Retorna 1 se o DEFAULT tem <amount> doses de LIQUID_*. Retorna 0 se não tiver.
[FUNCTION liquidtest]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (<liquidcont <LOCAL.liq>> >= <LOCAL.qtd>)
 RETURN 1
ELSE
 RETURN 0
ENDIF

//*****************************************************************************
// consumeliquid <amount>,<LIQUID_*>
//*****************************************************************************
//Consome <amount> doses de LIQUID_* e retorna 1. Se não tiver o suficiente,
// consome tudo que tiver porem retorna 0
[FUNCTION consumeliquid]
IF (<IsEmpty <argv[1]>>)
 LOCAL.qtd=1
 LOCAL.liq=<argv[0]>
ELSE
 LOCAL.qtd=<argv[0]>
 LOCAL.liq=<argv[1]>
ENDIF
IF (!<IsNum <LOCAL.liq>>)
 IF (STRMATCH(LIQUID_*,<LOCAL.liq>))
  LOCAL.liq=<DEF.<LOCAL.liq>>
 ELSE
  say esquece
  RETURN 0
 ENDIF
ENDIF
FORCONTTYPE t_recipient 2
 if (<more2>==<LOCAL.liq>)
  LOCAL.qtd -= <ConsumeRecipient <LOCAL.qtd>>
  IF (<LOCAL.qtd> <= 0)
   RETURN 1
  ENDIF
 endif
ENDFOR
RETURN 0

//*****************************************************************************
// split_key_val( string )
//*****************************************************************************
//separa uma string q esteja no formato "valor chave, valor chave" em uma tabela
//temporaria.
//o numero de linhas é encontrado em ctag.spkv_keys
//os resultados estao em ctag.spkv_rXX_k para chaves e ctag.spkv_rXX_v para valores
//XX vai de 0 a (ctag.spkv_keys - 1)
//um exemplo de uso pode ser para separar a lista de foodtype dos NPCs

//key separator: ','
//val separator: ' '
[FUNCTION split_key_val]

LOCAL.s=<args>
LOCAL.i=<strpos 0 , <LOCAL.s>>
ctag.spkv_keys=0

if (strlen(<args>)<=1)
    return
endif

while ( <LOCAL.i> > 0 && <ctag0.spkv_keys=0> < 10 )
    split_key_val_ <strsub 0 <LOCAL.i> <LOCAL.s>>

    LOCAL.s=<strsub <eval <LOCAL.i>+1> 60 <LOCAL.s>>
    LOCAL.i=<strpos 0 , <LOCAL.s>>
endwhile
split_key_val_ <LOCAL.s>

[FUNCTION split_key_val_]
LOCAL.s=<strtrim <args>>
LOCAL.a=<strarg <LOCAL.s>>
LOCAL.b=<streat <LOCAL.s>>

if (strlen(<LOCAL.b>)>1)
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.b>
    ctag.spkv_r<ctag.spkv_keys>_v=<LOCAL.a>
else
    ctag.spkv_r<ctag.spkv_keys>_k=<LOCAL.a>
    ctag.spkv_r<ctag.spkv_keys>_v=0
endif
ctag.spkv_keys += 1

//*****************************************************************************
// UID.inContainer( containerUid )
//*****************************************************************************
//retorna 1 se UID estiver no container containerUid
[FUNCTION inContainer]
REF1=<argv0>
//ignora se chegar em um char/player
if (<uid> < 040000000)
    return 0
//ok, achou    
elif (<cont>==<ref1>)
    return 1
//nao eh mas tem mais container pra procurar
elif (<cont>)
    return <cont.inContainer <ref1>>
//acabou, nao achou
else
    return 0
endif

//*****************************************************************************
// skillchance <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
//rotina do TARAN similar a skillcheck
//retorna uma chance, de 0 a 1000 baseado no valor fornecido skillValue, o valor
//de comparação valueRequired e o valor de -3dB da curva boca de sino.
[FUNCTION skillchance]
LOCAL.db=<argv2>
if !<argv2>
    LOCAL.db=100
endif
LOCAL.skill_diff=<eval <argv1>-<argv0>>
LOCAL.skill_bell=<eval randbell( <LOCAL.skill_diff>,<LOCAL.db>)>
if <LOCAL.skill_diff> < 0
    LOCAL.skill_bell=<eval 1000 - <LOCAL.skill_bell>>
endif
return <LOCAL.skill_bell>

//*****************************************************************************
// belltest <skillValue>,<valueRequired>,[<-3dbDistance>]
//*****************************************************************************
[FUNCTION belltest]
if <R1000> < <skillchance <argv0>,<argv1>,<argv2>>
    return 1
else
    return 0
endif

//*****************************************************************************
// skill_repeat <gain_skill>
//*****************************************************************************
//Repete a ultima skill (<argn1>) de gather resource. Ganha skill nesse swing se <argn2>
[FUNCTION skill_repeat]
if (0<argn2>)
 skill_gain <src.action>
endif
timerf 1 action=<argn1>


//*****************************************************************************
// playeritem
//*****************************************************************************
//Mostra quanto de um determinado ID o player tem na bag + bank. ou num target container qualquer
[FUNCTION playeritem]
if <isempty <args>>
//    sysmessageyellow Use .playeritem ITEM_ID
    promptconsole playeritem Qual ITEM_ID?
elif <argo>
    LOCAL.pack=<argo.rescount <args>>
    LOCAL.bank=<argo.findlayer.layer_bankbox.rescount <args>>
    LOCAL.total=<eval <LOCAL.pack>+<LOCAL.bank>>
    sysmessagegreen <argo.tag.name> tem <dLOCAL.total> <args>.
else
    sysmessagered Selecione o alvo:
    targetfg playeritem <args>
endif

//*****************************************************************************
// unstack
//*****************************************************************************
[FUNCTION unstack]

if (!<argo>)
    src.sysmessageyellow Selecione o item para desempilhar.
    targetf unstack <argv0>
    return 1
endif

LOCAL.x=1
if (<isnum <argv0>>)
    if (<argv0> > 0)
        LOCAL.x=<argv0>
    endif
endif

//Correção do bug de amount de corpses. Não tem outro meio MESMO!
if (<argo.type>==t_corpse)
    src.sysmessageyellow Selecione o item para desempilhar.
    targetf unstack <argv0>
    return 1
endif

if (<LOCAL.x> >= <argo.amount>)
    src.sysmessageyellow Nao pode tirar <eval <argo.amount>> ou mais.
else
    argo.amount -= <LOCAL.x>
    argo.update
    //copia item
    serv.newdupe <argo.uid>
    new.amount=<LOCAL.x>
    //muda color pra nao dar stack de novo
    new.color=-1
    //bounce primeiro pra colocar em posicao diferente na bag
    new.bounce
    new.cont=<argo.cont>
    new.color=<argo.color>
    src.sysmessageyellow <dLOCAL.x> removido(s) da pilha. Ficaram: <eval <argo.amount>>
endif

//*****************************************************************************
// splitStack stack,amount
//*****************************************************************************
//return a dupe or the original with 'amount'
[FUNCTION splitStack]
REF1=<argv0>
LOCAL.amount=<argv1>

if ( <LOCAL.amount> < <REF1.amount> )

    //duplica item, arruma a quantidade
    SERV.NEWDUPE <REF1>
    NEW.amount = <LOCAL.amount>

    //acerta quantidade restante
    REF1.amount -= <LOCAL.amount>

    return <NEW>
else
    return <REF1>
endif

//*****************************************************************************
// giveUniqueItem
//*****************************************************************************
[FUNCTION giveUniqueItem]
wipeObject <args>
serv.newitem <args>
src.bounce <new>

//*****************************************************************************
// worldrespawn
//*****************************************************************************
//Reseta os spawnpoints de todo o world. Deixar PLEVEL 6
[FUNCTION worldrespawn]
ctag.lastp=<p>
obj=<uid>
local.i=0
serv.b Aguarde enquanto o mundo eh repopulado.
FORITEMS 6144
 IF (<TYPE> == t_spawn_char) 
  obj.p=<p>
  obj.dclick <uid>
  timerd=<R4,30>
  local.i += 1
 ENDIF
END
p=<ctag.lastp>
ctag.lastp=
sysmessagered Reiniciados <dlocal.i> spawn points.
serv.b Fim da repopulacao mundial.

//****************************************************************************
//
//              Sistema de help
//
//****************************************************************************
[COMMENT HELP]
Esta seção deve ser movida daqui para um novo arquivo assim que depurada.
Sempre que o botão Help do client é acionado, a função HelpPage é chamada.
Foi criado um sistema de Help gump based com links externos para o Wiki
Para abrir o browser para um dado link usa-se o comando WEBLINK <link>

[FUNCTION HelpPage]
dialog d_help

[DIALOG d_help]
100,75
page 0
resizepic 50 31 2620 500 400
checkertrans 55 38 490 385
gumppic 0 0 10400
gumppic 0 160 10401
gumppic 0 356 10402
gumppic 518 -2 10410
gumppic 518 160 10411
gumppic 518 356 10412
gumppic 225 45 2501
dtext 231 45 26 Mystical Tales Shard
resizepic 92 87 2620 416 124
dtext 256 93 48 Estatisticas
resizepic 92 226 2620 416 91
resizepic 92 329 2620 416 84
dtext 104 112 166 Existem <serv.clients> jogadores online no momento.
if (<serv.account.<src.account>.plevel>) //jogador regular
 dtext 104 128 166 O servidor esta rodando ha <eval <serv.timeup>/86400> dias desde o ultimo reset.
 dtext 104 144 166 O mundo tem <serv.age> dias, <serv.items> itens e <serv.chars> personagens.
 dtext 104 160 166 O servidor esta usando <eval <serv.mem>/1024>MB de memoria.
else					//jogador novo. Sem formulario.
 dtext 104 128 166 Voce ja tentou responder o formulario de admissao <eval <serv.account.<src.account>.tag.form.try>> vezes.
 dtext 104 144 166 Voce pode modificar suas questoes quando quiser
 dtext 104 160 166 atravez desta janela. Use os guias para maiores detalhes.
endif
dtext 104 176 166 Existe um total de <serv.accounts> contas cadastradas no servidor.
dtext 277 232 48 Guias
button 104 252 2224 2223 1 0 1
dtext 128 248 166 Racas
button 104 268 2224 2223 1 0 2
dtext 128 264 166 Ambientacao
button 104 285 2224 2223 1 0 3
dtext 128 280 166 Criacao de personagem
button 296 252 2224 2223 1 0 4
dtext 320 248 166 Skills
button 296 268 2224 2223 1 0 5
dtext 320 264 166 Sistemas diversos
dtext 320 280 166 Tabela de precos
button 296 285 2224 2223 1 0 6
dtext 264 336 48 Problemas?
button 104 356 2224 2223 1 0 7
dtext 128 352 166 Pergunte em nosso Forum
button 104 372 2224 2223 1 0 8
dtext 128 368 166 Reportar um bug/mau-funcionamento
if (<serv.account.<src.account>.plevel>) //jogador regular
 button 104 388 2224 2223 1 0 9
 dtext 128 384 166 Chame um Game Master
else
 button 104 388 2224 2223 1 0 10
 dtext 128 384 166 Rever meu formulario
endif
[DIALOG d_help text]
Mystical Tales Shard
Estatisticas
Existem <serv.clients> jogadores online no momento.
O servidor esta rodando ha <serv.age> dias desde o ultimo reset.
Existem <serv.items> itens e <serv.chars> personagens no mundo.
O servidor esta usando <serv.mem>kb de memoria.
Existe um total de <serv.accounts> contas cadastradas no servidor.
Guias
Racas
Classes
Criacao de personagem
Skills
Sistemas diversos
Tabela de precos
Problemas?
Pergunte em nosso Forum
Reportar um bug/mau-funcionamento
Chame um Game Master

[DIALOG d_help button]
ON=1
// Raças
WEBLINK www.myt.com.br/wiki/index.php?title=Ra%C3%A7as

ON=2
// Ambientação
WEBLINK wiki.myt.com.br/index.php/Hist%C3%B3rias_do_Reino

ON=3
// Criação de char
WEBLINK www.myt.com.br/wiki/index.php?title=Cria%C3%A7%C3%A3o_de_personagem

ON=4
// Skills
WEBLINK www.myt.com.br/wiki/index.php/Category:Skills

ON=5
// Sistemas
WEBLINK www.myt.com.br/wiki/index.php/Category:Sistemas

ON=6
// Tabela de preços
DIALOG d_merchant_guild 2

ON=7
// Forum
WEBLINK forum.myt.com.br/

ON=8
// Bug
WEBLINK www.myt.com.br/smf/index.php?topic=825

ON=9
// Page
if (!<serv.account.<src.account>.plevel>)
 sysmessagered Voce ainda nao pode fazer isso...
 return 1
endif
sysmessagered ATENCAO!!!
sysmessageyellow Descreva seu problema com precisao. Seja direto e nao brinque com este sistema sob pena de prisao!
GMPAGE Other

ON=10
//Formulário
if (<serv.account.<src.account>.plevel>)
 sysmessagered Voce ja eh um jogador aceito.
 return 1
endif
playerform

[EOF]
